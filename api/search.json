[{"id":"7957ef06823b340dc739eb1014c53ddf","title":"MyBatis study day01","content":"JavaEE 三层架构表现层: 可视化用户接触层\n业务层: 实现业务逻辑层\n持久层: 数据库交互层 Mybatis就是作用在这\n它是为了简化JDBC而产生的的一套框架\n接下来的实验, 创建一个数据库, 一张表, 查询表里的所有数据: \n\n\n入门_MyBatis中文网\n1. 创建表\nCreate DATABASE Mybatis;\nUse Mybatis;\n\ndrop table if EXISTS tb_user;\n\ncreate table tb_user(\n\tid int PRIMARY KEY auto_increment,\n\tusername VARCHAR(20),\n\tpassword VARCHAR(20),\n\tgender char(1),\n\taddr VARCHAR(30)\n\t);\n\n\ninsert into tb_user VALUES (1, &#39;zhangsan&#39;,&#39;123&#39;, &#39;男&#39;, &#39;北京&#39;), (2, &#39;李四&#39;, &#39;234&#39;, &#39;女&#39;, &#39;天津&#39;), (3, &#39;王五&#39;, &#39;11&#39;, &#39;男&#39;, &#39;西安&#39;);\n\n2. 创建项目, Maven依赖&lt;dependency&gt;\n  &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;3.5.11&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n  &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;8.0.29&lt;&#x2F;version&gt;\n\n&lt;&#x2F;dependency&gt;\n\n3. 创建Mybatis xml配置文件具体代码看官网, 只要注意更改里面数据库的信息就可以了, 还有注意xml配置文件的导入\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;\n\n&lt;configuration&gt;\n    &lt;environments default&#x3D;&quot;development&quot;&gt;\n        &lt;environment id&#x3D;&quot;development&quot;&gt;\n            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;\n            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;mybatis&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;Sxs12367&quot;&#x2F;&gt;\n            &lt;&#x2F;dataSource&gt;\n        &lt;&#x2F;environment&gt;\n    &lt;&#x2F;environments&gt;\n    &lt;mappers&gt;\n\n&lt;!--        这是查询xml的导入--&gt;\n        &lt;mapper resource&#x3D;&quot;UserMapper.xml&quot;&#x2F;&gt;\n    &lt;&#x2F;mappers&gt;\n&lt;&#x2F;configuration&gt;\n\n4. 创建存储数据的类package com.MyCompany.pojo;\n\npublic class User &#123;\n\n    private Integer id;\n    private String username;\n    private String password;\n    private String gender;\n    private String addr;\n    \n    &#x2F;&#x2F;后面的getset方法, tostring方法全部省略\n\n5. 创建映射器(Mapper)这个映射器就是上面配置xml中添加的mapper\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n\n&lt;!--名称空间, 加上下面的id, 一起确定唯一查询语句--&gt;\n&lt;mapper namespace&#x3D;&quot;test&quot;&gt;\n    &lt;!--后面的resultType用于表示查询单挑数据存放的类, 就是我们创建的User类---&gt;\n    &lt;select id&#x3D;&quot;selectAll&quot; resultType&#x3D;&quot;com.MyCompany.pojo.User&quot;&gt;\n        select * from tb_user;\n    &lt;&#x2F;select&gt;\n&lt;&#x2F;mapper&gt;\n\n\n\n6. 创建main方法, 启动查询代码在官网都有, \npublic class Mybatis_demo\n&#123;\n    public static void main( String[] args ) throws IOException &#123;\n\n        &#x2F;&#x2F;创建 SqlSessionFactory 工厂对象, 为了创建sqlSession对象\n        &#x2F;&#x2F; String传入myBatis配置文件\n        String resource &#x3D; &quot;mybatis-config.xml&quot;;\n        InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);\n        SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);\n\n        &#x2F;&#x2F;创建SqlSession\n        SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();\n\n        &#x2F;&#x2F;执行sql, 因为查询结果是一个List, 所以用List的方法, 参数就是名称空间.id\n        List&lt;User&gt; users &#x3D; sqlSession.selectList(&quot;test.selectAll&quot;);\n\n        System.out.println(users);\n\t\t\n        &#x2F;&#x2F;注意关掉查询\n        sqlSession.close();\n\n\n\n    &#125;\n&#125;\n\n最后的结构\nMapper代理\n调用xml中的查询方法没有代码补全, 比较麻烦, 所以我们会用mapper代理开发sql查询语句\n1. 创建Mapper接口Mapper是一个接口, 但是它必须和sql映射文件同名, 并且放在同一目录下\n\n\n\n\n\n\n提示\n创建包时,  报名之间的.可以使一个包变成一层层的文件夹, 但是创建普通文件夹的时候, 我们就要用如下的方法:\n“com&#x2F;MyCompany&#x2F;Mapper”\n\n\npublic interface UserMapper &#123;\n\n    &#x2F;&#x2F;这里的方法返回类型需要和mapper中一致, 参数也要一致\n    &#x2F;&#x2F; 这里的方法名就是mapper中的id.\n    List&lt;User&gt; selectAll();\n\n&#125;\n\n这样也是在同一目录下:\n\n2. 更新myBatis配置文件Mapper地址    &lt;mappers&gt;\n\n&lt;!--        这是查询xml的导入--&gt;\n&lt;!--        &lt;mapper resource&#x3D;&quot;com&#x2F;MyCompany&#x2F;Mapper&#x2F;UserMapper.xml&quot;&#x2F;&gt;--&gt;\n&lt;!--        上面是单条导入, 一般用下面的方法, 直接整包导入--&gt;\n        &lt;package name&#x3D;&quot;com.MyCompany.Mapper&quot;&#x2F;&gt;\n    &lt;&#x2F;mappers&gt;\n\n3. 更新Mapper配置文件中的namespace&lt;!--名称空间--&gt;\n&lt;mapper namespace&#x3D;&quot;com.MyCompany.Mapper.UserMapper&quot;&gt;\n    &lt;select id&#x3D;&quot;selectAll&quot; resultType&#x3D;&quot;com.MyCompany.pojo.User&quot;&gt;\n        select *\n        from tb_user;\n    &lt;&#x2F;select&gt;\n&lt;&#x2F;mapper&gt;\n\n注意, 要更新namespace为包目录下的对应接口\n4. 在main方法中更改&#x2F;&#x2F;创建SqlSession\n\nSqlSession sqlSession &#x3D; sqlSessionFactory.openSession();\n\n&#x2F;&#x2F;调用sqlSession方法得到相应的mapper类\nUserMapper mapper &#x3D; sqlSession.getMapper(UserMapper.class);\nList&lt;User&gt; users &#x3D; mapper.selectAll();\n\n\nSystem.out.println(users);\n\n以后统一用mapper代理了. \n","slug":"MyBatis/MyBatis-study-day01","date":"2022-11-15T12:31:54.000Z","categories_index":"Study","tags_index":"MyBatis","author_index":"Someone Serious"},{"id":"fec74b413dc2868cc0a4ce6e062f6692","title":"MySql Study day01","content":"数据库设计一对一一般用于表拆分, 一张用于常用查询, 一张用于非常用查询, 通过设置唯一外键实现\n一对多设置外键, 多的一放设置外键, 指向一的一放的主键. \n多对多设置另一张表, 包含两个外键, 包含两个表的两个主键. \n\n多表查询select 字段列表 from 表 where 字段名 &#x3D; (子查询)\n\n单行单列直接用大于小于等于\n多列单行用in()查询\n多行多列作为from后面的表进行查询\nselect 字段列表 from (子查询)t1 where 字段名 &#x3D; ...\n\n子查询后面跟的t1用来称呼前面的子查询.\n内连接select\n\ttable1.id\n\ttable1.name\n\ttable2.data\n\ttable3.data\nfrom\n\ttable1\nInner join table2 on table2.id &#x3D; table1.id\nInner join table3 on table3.id &#x3D; table1.id\n\n\n\nJDBC是java语言来操作sql语言的一套API接口, java代码没有办法用同一套代码操控不同的数据库, 所以为了解决这个问题, sun公司创造了JDBC规范, 就是一个接口, 而不同的数据库则根据JDBC制作实现类, 我们以后就可以通过接口用同一套代码了, 当然要导入相应数据库的实现类, 就是相应数据库的jar包, 也叫驱动.\n\n导入JDBC\n导入相应的驱动\n&lt;dependency&gt;\n  &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;8.0.28&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n代码展示\npackage com.myCompany.JDBC;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.Statement;\n\npublic class JDBCDemo &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n\n        &#x2F;&#x2F; 1. 导入相关驱动\n        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n\n        &#x2F;&#x2F;2. 创建相关连接\n        String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jdbc_demo&quot;;\n        String userName &#x3D; &quot;root&quot;;\n        String password &#x3D; &quot;Sxs12367&quot;;\n        Connection connection &#x3D; DriverManager.getConnection(url, userName, password);\n\n        &#x2F;&#x2F;3. 编写相关查询语句\n        String sql &#x3D; &quot;create TABLE table_demo(\\n&quot; +\n                &quot;    id int primary key ,\\n&quot; +\n                &quot;    name varchar(10) not null ,\\n&quot; +\n                &quot;    money int\\n&quot; +\n                &quot;);&quot;;\n\n        &#x2F;&#x2F;4. 由相关连接创建一个相关查询(新建查询)\n        Statement statement &#x3D; connection.createStatement();\n\n        &#x2F;&#x2F;5. 查询, 返回值count &#x3D; 影响行数\n        int count &#x3D; statement.executeUpdate(sql);\n        \n        &#x2F;&#x2F;6. 释放内存\n        connection.close();\n        statement.close();\n    &#125;\n&#125;\n\n\n\n\n\n\n\n提示\n现在的高版本启动已经不需要第一行导入驱动的代码了, 现在自动导入. \nurl的格式是 ** jdbc:mysql:&#x2F;&#x2F;(ip地址+端口号)&#x2F;(数据库名)\n如果是本机的3306号端口的话, 可以省略.\n\n\n\n通过connection来操作事务\npublic class JDBCDemo &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n\n&#x2F;&#x2F;        &#x2F;&#x2F; 1. 导入相关驱动\n&#x2F;&#x2F;        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n\n        &#x2F;&#x2F;2. 创建相关连接\n        String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jdbc_demo&quot;;\n        String userName &#x3D; &quot;root&quot;;\n        String password &#x3D; &quot;Sxs12367&quot;;\n        Connection connection &#x3D; DriverManager.getConnection(url, userName, password);\n\n        &#x2F;&#x2F;3. 编写相关查询语句\n        String sql1 &#x3D; &quot;create TABLE table_demo(\\n&quot; +\n                &quot;    id int primary key ,\\n&quot; +\n                &quot;    name varchar(10) not null ,\\n&quot; +\n                &quot;    money int\\n&quot; +\n                &quot;);&quot;;\n        String sql2 &#x3D;&quot;drop TABLE  table_demo;&quot;;\n\n        &#x2F;&#x2F;4. 由相关连接创建一个相关查询(新建查询)\n        Statement statement &#x3D; connection.createStatement();\n\n        try &#123;\n            &#x2F;&#x2F;开启事务\n            connection.setAutoCommit(false);\n\n            statement.executeUpdate(sql1);\n            statement.executeUpdate(sql2);\n            &#x2F;&#x2F;提交事务\n            connection.commit();\n\n        &#125;catch (Exception e)&#123;\n            &#x2F;&#x2F;回滚事务\n            connection.rollback();\n            System.out.println(&quot;回滚事务&quot;);\n        &#125;\n\n\n        &#x2F;&#x2F;6. 释放内存\n        connection.close();\n        statement.close();\n    &#125;\n&#125;\n\nStatement返回值处理\n如果是处理DML语言, 就是对数据进行增删改操作时, 如果成功返回值是大于0的, 可以通过此判断, 但是如果是DDL, 就是对数据库或者表的元素的增删改, 他的值即使成功也有可能为0, 判断方法是不报错就是成功. \n\nStatement查询语句处理\npublic class JDBCDemo &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n\n&#x2F;&#x2F;        &#x2F;&#x2F; 1. 导入相关驱动\n&#x2F;&#x2F;        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n\n        &#x2F;&#x2F;2. 创建相关连接\n        String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jdbc_demo&quot;;\n        String userName &#x3D; &quot;root&quot;;\n        String password &#x3D; &quot;Sxs12367&quot;;\n        Connection connection &#x3D; DriverManager.getConnection(url, userName, password);\n\n        Statement statement &#x3D; connection.createStatement();\n\n        String sql &#x3D; &quot;select * from table_demo;&quot;;\n        &#x2F;&#x2F;注意, DQL语句的方法和其他方法不一样, 会返回一个ResultSet类型的查询结果\n        ResultSet resultSet &#x3D; statement.executeQuery(sql);\n\n        &#x2F;&#x2F;.next()返回下一行是否不为空, 并将指针移动到下一行, 一开始在第一行数据的上一行\n        while (resultSet.next())&#123;\n\n            &#x2F;&#x2F; 用getxxx的方法获取数据, 参数可以填列数, 也可以填列名, 注意! 列数从1开始\n            System.out.println(resultSet.getInt(1));\n            System.out.println(resultSet.getString(2));\n            System.out.println(resultSet.getInt(&quot;money&quot;));\n            System.out.println(&quot;-----------------&quot;);\n        &#125;\n\n\n        &#x2F;&#x2F;6. 释放内存, 注意要释放掉resultSet的内存\n        resultSet.close();\n\n\n        connection.close();\n        statement.close();\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n注意\n实际业务中我们并不是直接处理数据, 而是要把它封装在一个实体类, 并装入一个列表中使用的, 代码展示入下\n\n\npackage com.myCompany.pojo;\n\npublic class User &#123;\n\n    private int id;\n    private String name;\n    private int money;\n\n    public User(int id, String name, int money) &#123;\n        this.id &#x3D; id;\n        this.name &#x3D; name;\n        this.money &#x3D; money;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;id&#x3D;&quot; + id +\n                &quot;, name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, money&#x3D;&quot; + money +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\n​\t\t\nString sql &#x3D; &quot;select * from table_demo;&quot;;\n&#x2F;&#x2F;注意, DQL语句的方法和其他方法不一样, 会返回一个ResultSet类型的查询结果\nResultSet resultSet &#x3D; statement.executeQuery(sql);\n\n&#x2F;&#x2F;.next()返回下一行是否不为空, 并将指针移动到下一行, 一开始在第一行数据的上一行\nList&lt;User&gt; list &#x3D; new ArrayList&lt;User&gt;();\nwhile (resultSet.next())&#123;\n\n    &#x2F;&#x2F; 用getxxx的方法获取数据, 参数可以填列数, 也可以填列名, 注意! 列数从1开始\n    User user &#x3D; new User(resultSet.getInt(&quot;id&quot;), resultSet.getString(&quot;name&quot;), resultSet.getInt(&quot;money&quot;));\n    list.add(user);\n&#125;\n\nfor (User user : list) &#123;\n    System.out.println(user);\n&#125;\n\nUser&#123;id&#x3D;1, name&#x3D;&#39;张三&#39;, money&#x3D;100&#125;\nUser&#123;id&#x3D;2, name&#x3D;&#39;李四&#39;, money&#x3D;200&#125;\nUser&#123;id&#x3D;3, name&#x3D;&#39;王五&#39;, money&#x3D;300&#125;\nUser&#123;id&#x3D;4, name&#x3D;&#39;赵六&#39;, money&#x3D;400&#125;\nUser&#123;id&#x3D;5, name&#x3D;&#39;刘能&#39;, money&#x3D;500&#125;\n\n\n\n\n\n\n\n\n提示\n一个绝妙的, 字符串合并的方法, 如下\n\n\nString x1 &#x3D; &quot;一段话&quot;;\nString x2 &#x3D; &quot;插入&quot;;\nString x3 &#x3D; &quot;完整&quot;;\n\n&#x2F;&#x2F;这是要达到的结果\nString x &#x3D; &quot;这是一段话, 我要进行一些插入, 让这句话显得完整&quot;;\n\n&#x2F;&#x2F;先这样写,在需要插入的地方写&#39;&#39;\nString m &#x3D; &quot;这是&#39;&#39;, 我要进行一些&#39;&#39;, 让这句话显得&#39;&#39;&quot;;\n\n&#x2F;&#x2F;然后依次添加 &quot;+String+&quot;\n\nm &#x3D; &quot;这是&#39;&quot;+x1+&quot;&#39;, 我要进行一些&#39;&quot;+x2+&quot;&#39;, 让这句话显得&#39;&quot;+x3+&quot;&#39;&quot;;\n\n\n\n\n\n\n\n\n\n\n特别注意\n要小心sql注入, 就是输入的数据经过处理之后影响到查询语句, 我们必须要用\n我们就放弃Statement了, 以后都用PreoaredStatment\n\n\n&#x2F;&#x2F;sql命令变量用 ? 代替\nString sql &#x3D; &quot;select name from table_demo where id &#x3D; ?;&quot;;\nint id &#x3D; 1;\n\n&#x2F;&#x2F;传入sql语句\nPreparedStatement preparedStatement &#x3D; connection.prepareStatement(sql);\n&#x2F;&#x2F;设置变量值, 排序还是从1开始\npreparedStatement.setInt(1, id);\n\n&#x2F;&#x2F;注意不需要再传多余的sql语句了\nResultSet resultSet &#x3D; preparedStatement.executeQuery();\n\n预编译性能更高, 所以用就完事了. 注意后面添加的参数, 添加参数要用?分割, 每个参数之间用&amp;连接\nString url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jdbc_demo?useServerPrepStmts&#x3D;true&quot;;\n\n数据库连接池这个就不做过多展开, 留一个学习传送门吧\n\n\n\n\n\n\n提示\nalt + 鼠标左键 可以实现列编辑\nctrl + alt + l 格式化\n\n\n","slug":"MySql/MySql-Study-day01","date":"2022-11-14T11:33:12.000Z","categories_index":"Study","tags_index":"MySql","author_index":"Someone Serious"},{"id":"a87786c9ccb2deebec2cb0b25e4021c7","title":"Java web Study day01","content":"黑马程序员新版JavaWeb基础教程，Java web从入门到企业实战完整版_哔哩哔哩_bilibili\n喂喂喂听得到吗!\n今天想看电影, 没人陪我看, 真tmd, 我感觉要学的东西快学不完了, G!\n我的mysql的服务器创建了, 账号为root, 密码为S\n不行了, 洗个衣服去看电影了. 估计又要明天再写了, 先去\n","slug":"javaWeb/Java-web-Study-day01","date":"2022-11-13T10:49:34.000Z","categories_index":"Study","tags_index":"javaWeb","author_index":"Someone Serious"},{"id":"f8bddff16c64cf44d055f0f968e054f2","title":"C study day01","content":"我觉得C语言足够难, 够我开一个档来学习, 但是我今天学C的目的是为了完成我的实验, 所以实验结束之后我估计就会搁置C一段时间. \n学习传送门\n留着学吧,\n","slug":"C/C-study-day01","date":"2022-11-14T14:44:27.000Z","categories_index":"Study","tags_index":"C","author_index":"Someone Serious"},{"id":"d8446112450bdc11bfa73254c1a2fc8c","title":"Spring Study day02","content":"前言今天是周末, 又是学习的一天, 从早学到晚, 感觉自己的腰椎要顶不住了. (；へ：)\n承接上文的xml配置对数组进行赋值private List&lt;String&gt; list;   &#x2F;&#x2F;注意这里是List 不是ArrayList\n\nprivate other o;\n\npublic User(int x, String str, List&lt;String&gt; list, other o) &#123; &#x2F;&#x2F;注意这里也是List, 不是ArrayList\n    this.x &#x3D; x;\n    this.str &#x3D; str;\n    this.list &#x3D; list;\n    this.o &#x3D; o;\n&#125;\n\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.myCompany.helloWorld.User&quot;&gt;\n    &lt;constructor-arg name&#x3D;&quot;o&quot; ref&#x3D;&quot;s&quot;&#x2F;&gt;\n\n    &lt;constructor-arg name&#x3D;&quot;str&quot; value&#x3D;&quot;&lt;String&quot;&quot;&#x2F;&gt;\n\n    &lt;constructor-arg name&#x3D;&quot;x&quot; value&#x3D;&quot;123&quot;&#x2F;&gt;\n    &lt;constructor-arg name&#x3D;&quot;list&quot;&gt;\n\n        &lt;list&gt;\n            &lt;value&gt;abc&lt;&#x2F;value&gt;\n            &lt;value&gt;def&lt;&#x2F;value&gt;\n            &lt;value&gt;ijn&lt;&#x2F;value&gt;\n            &lt;value&gt;mkl&lt;&#x2F;value&gt;\n        &lt;&#x2F;list&gt;\n\n    &lt;&#x2F;constructor-arg&gt;\n&lt;&#x2F;bean&gt;\n\n\n\n\n\n\n\n提示\nList与ArrayList的区别\nArrayList是List的实现类, List只是一个接口. 所以下面的代码可以实现:\nList list &#x3D; new List();&#x2F;&#x2F;报错\nList list &#x3D; new ArrayList();&#x2F;&#x2F;正确\n\n\n\n集合和字典:private Map&lt;String, String&gt; map;\nprivate Set&lt;String&gt; set;\n\n&lt;constructor-arg name&#x3D;&quot;map&quot;&gt;  &lt;!--换成property都是一样的---&gt;\n\n    &lt;map&gt;\n        &lt;entry key&#x3D;&quot;张三&quot; value&#x3D;&quot;zhangsan&quot;&#x2F;&gt;\n        &lt;entry key&#x3D;&quot;李四&quot; value&#x3D;&quot;lisi&quot;&#x2F;&gt;\n    &lt;&#x2F;map&gt;\n\n&lt;&#x2F;constructor-arg&gt;\n\n&lt;constructor-arg name&#x3D;&quot;set&quot;&gt;\n\n    &lt;set&gt;\n        &lt;value&gt;张三&lt;&#x2F;value&gt;\n        &lt;value&gt;李四&lt;&#x2F;value&gt;\n        &lt;value&gt;王五&lt;&#x2F;value&gt;\n        &lt;value&gt;赵六&lt;&#x2F;value&gt;\n    &lt;&#x2F;set&gt;\n\n&lt;&#x2F;constructor-arg&gt;\n\n\n\n\n\n\n\n提示\nSystem.out.println(Arrays.toString(list)); &#x2F;&#x2F; 注意里面放的是数组, 不是List, 这个方法可以快速格式化输出数组\n\n\n\n注入对象类型值&lt;entry key-ref&#x3D;&quot;test&quot; value&#x3D;&quot;zhangsan&quot;&gt;&lt;&#x2F;entry&gt;\n\n其他同理\n通过util产生公共的对象, 然后引用首先要改变xml\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:util&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&quot; \n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&#x2F;spring-util.xsd&quot;&gt;\n\n注意上面的xmlns:util是新的添加, 还有在xsi上面新加的链接,\n声明公共的对象\n&lt;util:list id&#x3D;&quot;list&quot;&gt;\n    &lt;value&gt;张三&lt;&#x2F;value&gt;\n    &lt;value&gt;李四&lt;&#x2F;value&gt;\n    &lt;value&gt;王五&lt;&#x2F;value&gt;\n    &lt;value&gt;赵六&lt;&#x2F;value&gt;\n&lt;&#x2F;util:list&gt;\n\n然后其他对象可以通过ref引入\n\n\n\n\n\n\n\n注意\n这里的引入引入的都是同一个对象, 地址一致\n\n\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.myCompany.helloWorld.User&quot;&gt;\n    &lt;constructor-arg name&#x3D;&quot;list&quot; ref&#x3D;&quot;list&quot;&#x2F;&gt;\n    &lt;constructor-arg name&#x3D;&quot;list2&quot; ref&#x3D;&quot;list&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n\n\nfactoryBean与普通beanfactoryBean返回类型是可自定义的, 只要引用FactoryBean的接口, 重写getObject()就可以实现, 但是我估计用不到, 所以就不详细展开了. \n单实例与多实例\n\n\n\n\n\n提示\n单实例的意思就是, 只有一个实例, 多个人引用的是同一个对象, 地址是一致的, 多实例就是每次引用创建一个新的对象, 地址之间不一致\n\n\n设置单实例与多实例:\n系统默认是单实例\n@Test\npublic void test()&#123;\n\n    ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);\n\n    User user1 &#x3D; applicationContext.getBean(&quot;user&quot;, User.class);\n    User user2 &#x3D; applicationContext.getBean(&quot;user&quot;, User.class);\n    System.out.println(user1);\n    System.out.println(user2);\n\n\n&#125;\n\n结果:\ncom.myCompany.helloWorld.User@1cab0bfb\ncom.myCompany.helloWorld.User@1cab0bfb\n\n进程已结束,退出代码0\n\n注意上面的结果, 地址值是一样的.\n设置多实例:\n&lt;!--    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.myCompany.helloWorld.User&quot; scope&#x3D;&quot;singleton&quot;&gt;--&gt;\n    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.myCompany.helloWorld.User&quot; scope&#x3D;&quot;prototype&quot;&gt;\n        &lt;constructor-arg name&#x3D;&quot;list&quot; ref&#x3D;&quot;list&quot;&#x2F;&gt;\n        &lt;constructor-arg name&#x3D;&quot;list2&quot; ref&#x3D;&quot;list&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n设置scope, 默认值是singleton,意思是单实例, 设置为prototype,多实例.\nbean的生命周期\n初始化(执行构造方法)\n\n调用set方法\n\n调用初始化方法(如下面代码的init-method)\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.myCompany.helloWorld.User&quot; scope&#x3D;&quot;prototype&quot; init-method&#x3D;&quot;helloWorld&quot;&gt;\n    &lt;constructor-arg name&#x3D;&quot;list&quot; ref&#x3D;&quot;list&quot;&#x2F;&gt;\n    &lt;constructor-arg name&#x3D;&quot;list2&quot; ref&#x3D;&quot;list&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\nbean实例获取, 就是:\nUser user1 &#x3D; applicationContext.getBean(&quot;user&quot;, User.class);\n\n销毁, 销毁的不是某一个bean, 而是整个xml配置实例,销毁代码:\nApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);\n((ClassPathXmlApplicationContext)applicationContext).close();\n\n&lt;bean id&#x3D;&quot;user2&quot; class&#x3D;&quot;com.myCompany.helloWorld.User2&quot; scope&#x3D;&quot;singleton&quot; destroy-method&#x3D;&quot;destroy&quot;&#x2F;&gt;\n\n注意上面代码的destroy-method, 就是销毁会调用的方法\n\n\n\n\n\n\n\n\n提示\n然而在多实例的bean中, destroy方法并不会被调用, 将bean销毁之后, 不会影响到它已经产生的类. 单实例的bean是在xml被实例化时候被创建的, 而多实例的bean是在被具体实例化时被创建的, 所以即使没有只创建的关于xml的实例化, 没有创建类的实例化, xml中的单实例类的初始化方法仍然会被调用, 而多实例则不会\n\n\nbean属性自动注入通过autowire的方式, 但是我们用不到. 百度再说\n德鲁伊连接池首先在maven中导入\n&lt;dependency&gt;\n  &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;1.2.4&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n然后在配置文件中更改:\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;\n\n\n    &lt;context:property-placeholder location&#x3D;&quot;jdbc.properties&quot;&#x2F;&gt;\n\n注意前面的xmlns与xsi中的更改, 在location中填写**.properties**文件\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.myCompany.helloWorld.User&quot; scope&#x3D;&quot;prototype&quot;&gt;\n    &lt;property name&#x3D;&quot;x1&quot; value&#x3D;&quot;$&#123;prop.x1&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;x2&quot; value&#x3D;&quot;$&#123;prop.x2&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;x3&quot; value&#x3D;&quot;$&#123;prop.x3&#125;&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n下面是properties文件, 这个文件我放在了和xml文件一样的resouces文件夹下. \n\n\n\n\n\n\n\n注意\n等号后面不要用空格\n\n\nprop.x1&#x3D;123\nprop.x2&#x3D;456\nprop.x3&#x3D;789\n\n\n\n注解方式管理Bean注解需要aop的包, 我们通过maven引入\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-aop&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;5.3.23&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n注解方式开启需要组件扫描, 在xml配置文件中, 我们仍然要引入context. 然后开启组件扫描:\n&lt;context:component-scan base-package&#x3D;&quot;com.myCompany&quot;&#x2F;&gt;\n\n\n\n\n\n\n\n提示\n在包路径里, 只写上层路径的意思是, 下层路径全部扫描, 如果想扫描多个包, 可以后面跟逗号, 注意: 逗号后面的路径也是全路径. \n\n\n&#x2F;&#x2F; 下面是注解的写法, 有四种@, 其实意思都一样, 只不过每一种@用在项目中的不同结构上, \n&#x2F;&#x2F; value就是唯一标识的id, 如果不写, 默认值就是类名, 但是首字母会小写\n\n@Component(value &#x3D; &quot;user&quot;)\n&#x2F;&#x2F;@Service\n&#x2F;&#x2F;@Controller\n&#x2F;&#x2F;@Repository\npublic class User &#123;\n\n    String x1;\n    public void helloWorld() &#123;\n\n        System.out.println(&quot;创建User成功&quot;);\n        System.out.println(x1);\n    &#125;\n\n    public void theEnd()&#123;\n        System.out.println(&quot;销毁User成功&quot;);\n    &#125;\n&#125;\n\n\n\n我觉得我有可能会做一个技术汇总, 就是写完这些混沌的知识之后, 总结出一股子脉络, 进项详细的排序, 但是感觉工作量有点大, 估计得等到我之后已经遗忘掉spring知识的时候我才会做一个基于博客的学习博客吧.标签我已经想好了, 就叫studyAgain\n关于context的扫描细节配置&lt;!--    use-default-filters默认为true, 表示意思是全部自动扫描, 选择false就表示不扫描, --&gt;\n&lt;!--    context:include-filter表示添加扫描文件, 后面的Controller表示只扫描@Controller的类\n        context:exclude-filter 和上面的相反, 表示不扫描什么东西--&gt;\n&lt;!--        这个type&#x3D;&quot;annotation&quot;表示的就是关于注释的处理--&gt;\n    &lt;context:component-scan base-package&#x3D;&quot;com.myCompany&quot; use-default-filters&#x3D;&quot;false&quot;&gt;\n        &lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Component&quot;&#x2F;&gt;\n        &lt;context:exclude-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Service&quot;&#x2F;&gt;\n    &lt;&#x2F;context:component-scan&gt;\n\n\n\n注释的注入@Value(value &#x3D; &quot;String x1&quot;)\nString x1;\n\n@Autowired\t&#x2F;&#x2F;表示通过类型自动注入, 但是如果一个类型接口下有多个类就会报错\n@Qualifier(value &#x3D; &quot;other&quot;)  &#x2F;&#x2F;通过id注入, 注意:在被注入的类前记得加@, 让context扫描到这个类, 这两个@一般连用, 虽然我也不知道为什么不能只用@Qualifier\nOther o;\n\n\n\n\n\n\n\n提示\n@Repository可以通过类型和id进行注入, 但是它是java的扩展包中的内容, 而不是spring中的内容, 所以不推荐使用\n\n\n完全注解开发可以完全使用注解而不使用xml文件进行开发, 到这里我们的Spring的IOC就学完啦\n我试试能不能跳转到SpringBoot学习.\n","slug":"springBoot/Spring-Study-day02","date":"2022-11-13T02:10:54.000Z","categories_index":"Study","tags_index":"Spring","author_index":"Someone Serious"},{"id":"f9ae6417e6d1f674d9c49adb056f5b6c","title":"Spring Study day01","content":"学习传送门\n首先明确: spring是为了使项目更加简便而设计的\n\n\n\n\n\n\n提示\nGA版本是稳定版\nSNAPSHOT是快照版\n\n\nSpring项目的创建使用maven, 先创建一个最基本的spring框架:\n写一个类的方法\npackage com.myCompany.helloWorld;\n\nimport javax.xml.bind.annotation.adapters.XmlJavaTypeAdapters;\nimport java.sql.SQLOutput;\nimport org.junit.Test;\n\npublic class User &#123;\n\n    public void helloWorld()&#123;\n        System.out.println(&quot;helloWorld&quot;);\n    &#125;\n\n&#125;\n\n写一个测试类\npackage com.myCompany.helloWorld;\n\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class TestRun &#123;\n\n    @Test\n    public void test()&#123;\n\n        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);\n\n        User user &#x3D; applicationContext.getBean(&quot;user&quot;, User.class);\n        System.out.println(user);\n        user.helloWorld();\n\n    &#125;\n\n&#125;\n\n\n在main下创建一个resources资源文件夹, 存放xml文件, 在xml文件中创建bean\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\n    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.myCompany.helloWorld.User&quot;&gt;&lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n然后运行测试类就可以了\n洗澡去了, 人要馊掉了\n\nIOC容器降低耦合, 将创建新的实体类的任务交给spring, 就是IOC, 上面的实践就是IOC\n它包括:\n1. xml解析\n1. 工厂模式\n1. 反射\n\n反射内容不一定和反射有关, 毕竟这也不是什么专业报告, 而是我的学习日记\njava关于类的初始化:\n类并不是在java项目启动时就全部初始化的, 而是动态的, 在调用到它时才初始化, 初始化便是将类方法中的所有静态的方法启动(构造方法当然也算静态方法, 即使它没有static关键字)\n看下面的代码:\npublic class Initable &#123;  \n    static final int staticFinal &#x3D; 47;  \n    static final int staticFianl2 &#x3D; ClassInitialization.rand.nextInt(1000); \n    static int notFinal &#x3D; 12;\n    static &#123;  \n        System.out.println(&quot;Initializing Initable&quot;);  \n    &#125;  \n&#125;\n\n像staticFinal属于编译期常量, 调用它不需要将类初始化, 注意, 必须要有final成为常量\n像第二三种就必须要初始化才可以调用了, 一旦初始化, 就会启动最后的打印方法\n而调用class.forName可以主动将类加载到内存中 , 主动初始化. \n\nIOC接口\nBeanFactory: IOC开发人员用的底层的, 功能更少, 咱们最好不要用\nApplicationContext: 给你用的, 用就完事了.\n\n\n\n\n\n\n\n提示\nctrl + h 可以打开类的关系图\n\n\n\n这两个方法都可以得到创建xml对象\nFileSystemXmlApplicationContext输入的是绝对路径\nClassPathXmlApplicationContext输入的是在src下的相对路劲, 但是我这里好像有点问题, 建议是在main下, 建立一个resouces文件夹, 这个方法也可以直接导航到该目录下\n创建对象之后的注入属性xml配置无参构造set的方法:创建一个类:\npublic class User &#123;\n\n    private int x;\n    private String str;\n\n    private other o;\n\n    public void setO(other o) &#123;\n        this.o &#x3D; o;\n    &#125;\n\n    public void setX(int x) &#123;\n        this.x &#x3D; x;\n    &#125;\n\n    public void setStr(String str) &#123;\n        this.str &#x3D; str;\n    &#125;\n\n    public void helloWorld()&#123;\n        System.out.println(&quot;helloWorld int x &#x3D; &quot; + x + &quot;, str &#x3D; &quot; + str);\n        System.out.println(&quot;the other class : &quot; + o);\n        System.out.println(x + 1);\n    &#125;\n\n\n&#125;\n\n他的配置文件 \n    &lt;bean id&#x3D;&quot;s&quot; class&#x3D;&quot;com.myCompany.helloWorld.other&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.myCompany.helloWorld.User&quot;&gt;\n        &lt;property name&#x3D;&quot;x&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;str&quot; value&#x3D;&quot;str&quot;&#x2F;&gt;\n\n\n&lt;!--        这里引用了s类, 用ref的方法.--&gt;\n        &lt;property name&#x3D;&quot;o&quot; ref&#x3D;&quot;s&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n有参构造的xml方法:类文件:\npublic class User &#123;\n\n    private int x;\n    private String str;\n\n    private other o;\n\n    public User(int x, String str, other o) &#123;\n        this.x &#x3D; x;\n        this.str &#x3D; str;\n        this.o &#x3D; o;\n    &#125;\n\n    public void helloWorld()&#123;\n        System.out.println(&quot;helloWorld int x &#x3D; &quot; + x + &quot;, str &#x3D; &quot; + str);\n        System.out.println(&quot;the other class : &quot; + o);\n        System.out.println(x + 1);\n    &#125;\n\n\n&#125;\n\n配置文件:\n&lt;!--    注意这里创建了一个s类--&gt;\n    &lt;bean id&#x3D;&quot;s&quot; class&#x3D;&quot;com.myCompany.helloWorld.other&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.myCompany.helloWorld.User&quot;&gt;\n        &lt;constructor-arg name&#x3D;&quot;o&quot; ref&#x3D;&quot;s&quot;&#x2F;&gt;\n        &lt;constructor-arg name&#x3D;&quot;str&quot; value&#x3D;&quot;string&quot;&#x2F;&gt;\n        &lt;constructor-arg name&#x3D;&quot;x&quot; value&#x3D;&quot;123&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\np方式注入我就提个名字, 想用的话百度吧. \n配置文件特殊用法\n设置空值\n&lt;constructor-arg name&#x3D;&quot;str&quot;&gt;\n    &lt;null&#x2F;&gt;\n&lt;&#x2F;constructor-arg&gt;\n\n用property同理\n\n如果遇到xml会解析到的特殊符号怎么办, 比如&lt;&gt;,可以用转义符号&amp;lt, &amp;gt为&lt;&gt;\n&amp;quot为”\n&lt;constructor-arg name&#x3D;&quot;str&quot; &gt;\n    &lt;!--字符串写在&quot;CDATA[&quot;后--&gt;   \n    &lt;value&gt;&lt;![CDATA[&lt;String&gt;]]&gt;&lt;&#x2F;value&gt;\n&lt;&#x2F;constructor-arg&gt;\n\n使用内部bean赋值\n&lt;constructor-arg name&#x3D;&quot;str&quot; &gt;\n    &lt;bean id &#x3D; &quot;&quot; class &#x3D; &quot;&quot;&gt;\n    &lt;!--进行内部bean的赋值, property同理--&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;constructor-arg&gt;\n\n级联赋值\n其实就是通过ref调用外部bean.\n\n\nIOC与DITheEND好啦, 今天的学习时光就到这里了, 下午两点半创建的文档, 现在已经是11点47了, 好啦886.\n","slug":"springBoot/Spring-Study-day01","date":"2022-11-12T06:33:30.000Z","categories_index":"Study","tags_index":"Spring","author_index":"Someone Serious"},{"id":"76ec667c92deac2437fb208989cf59f5","title":"Maven res 01 HelloWorld","content":"学习传送门\n目的描述​\t1. 创建一个Maven项目, 其中包括父类 maven_parent, 以及他的三个子模块maven_dao, maven_service, maven_controller\n​\t2. 三个子模块的用途与依赖关系\n\n\n\n\nmaven_dao\nmaven_service\nmaven_controller\n\n\n\n简述\n数据库访问层\n项目业务逻辑层\n接受请求,相应数据\n\n\n模板\nquickstart\nquickstart\nwebapp\n\n\n依赖\n\nmaven_dao\nmaven_serviceservlet\n\n\n插件\n\n\ntomcat\n\n\n\n实现过程创建项目\n选择模板项目, 更改项目名称\n\n更改项目ID, 然后刷新Maven\n\n新建模块时注意填写Maven模板\n\n添加依赖\nmaven_dao中的方法\n\n向service中添加dao的依赖, 注意图中的写法\n\n编写service方法, 并引用maven_dao中的方法\n\nmaven_controller方法需要载入插件servlet, 然后实现其中的方法, 超入插件的方法如下:\n\n搜索mvn, 进入Maven库官网, 然后搜索对应的插件, 以及版本, 如果不知道用什么版本, 看人数最多的就可以了.\n\n\n复制代码到pom.xml下\n\n创建servlet类, 重写它的方法, servlet我还没有学, 之后可能会写详细说明\n\n\n然后还要依赖maven_service, pom.xml如下:\n&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;javax.servlet&#x2F;javax.servlet-api --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.1.0&lt;&#x2F;version&gt;\n    &lt;scope&gt;provided&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n    &lt;artifactId&gt;maven_service&lt;&#x2F;artifactId&gt;\n    &lt;groupId&gt;com.myCompany&lt;&#x2F;groupId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n代码重写servlet方法:\n首先发现在controller下没有java这个包, 所以我们要手动创建:\n\n重写方法:\n@WebServlet(&quot;&#x2F;user&quot;)\npublic class UserServlet extends HttpServlet &#123;\n\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        System.out.println(&quot;myServlet complete...&quot;);\n        \n        &#x2F;&#x2F;调用service中的方法:\n        useDao.use_dao();\n    &#125;\n&#125;\n\n\n想要运行的话还是要添加jetty或者tomcat的插件打开服务器, 插件添加在&lt;plugins&gt;下方, 而它又放在&lt;bulid&gt;的下方\ntomcat的插件去tomcat的官网下载:插件官网\n&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.tomcat.maven&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;tomcat6-maven-plugin&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.2&lt;&#x2F;version&gt;\n    &lt;configuration&gt;\n        &lt;hostName&gt;localhost&lt;&#x2F;hostName&gt;        &lt;!--   Default: localhost --&gt;\n        &lt;port&gt;8080&lt;&#x2F;port&gt;                     &lt;!-- 启动端口 Default:8080 --&gt;\n        &lt;path&gt;&#x2F;tomcat&lt;&#x2F;path&gt;   &lt;!-- 访问应用路径  Default: &#x2F;$&#123;project.artifactId&#125;--&gt;\n        &lt;uriEncoding&gt;UTF-8&lt;&#x2F;uriEncoding&gt;      &lt;!-- uri编码 Default: ISO-8859-1 --&gt;\n    &lt;&#x2F;configuration&gt;\n&lt;&#x2F;plugin&gt;\n\n如何使用tomcat启动服务器:\n\n\n注意添加命令, 然后更改下列属性\n\n在启动之前需要将项目打包, 生成target文件\n\n\n\n\n\n\n\n\n注意\n第一次构建项目的时候, 一定要先构建父类, 然后再点击按钮构建项目\n\n\n\n然后我们就运行成功了!\n\n\n\nTheEND","slug":"Maven/Maven-res-01","date":"2022-11-12T03:14:14.000Z","categories_index":"Result","tags_index":"Maven","author_index":"Someone Serious"},{"id":"c2a9e80eefc355aef707e141e0e47a0d","title":"Maven-Study-day01","content":"学习传送门\nMaven帮助我们下载管理依赖的包&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;druid.version&#125;&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\ngroupId: 实际的包的仓库路径, 也就是实际项目公司名称\nartifaceId: 实际项目中的一个Maven模块(项目名), \nversion: 版本\n\n统一jar包依赖\n统一项目目录结构\n一致构建模型插件机制\n\nMaven的统一项目结构\n在若依项目中的体现:\n\npom.xml是用来存放所有的依赖jar包和插件的\n至于pom.xml中的标签含义, 有一个超级pom中包含所有标签, 就在 传送门下面的POM标签大全详解里. \nMaven设置的xml与包路径设置\n在xml中设置包路径如下图, 其中注意是用 /而不是\\\n&lt;!-- 下载包的地址 --&gt;\n&lt;localRepository&gt;D:&#x2F;repository&lt;&#x2F;localRepository&gt;\n\n还可以设置阿里云的镜像, 因为maven的服务器在国外, 下载很慢, 所以设置阿里的镜像会快一点\n&lt;mirrors&gt;\n    &lt;mirror&gt;\n        &lt;id&gt;alimaven&lt;&#x2F;id&gt;\n        &lt;name&gt;aliyun maven&lt;&#x2F;name&gt;\n        &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;\n        &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;\n    &lt;&#x2F;mirror&gt;\n&lt;&#x2F;mirrors&gt;\n\n\n\n下面是创建Maven的过程\n其中archetype是指Maven的模板, 一般选择quickstart就行了, 有特殊需要再更换, 选错了不影响.\n\n更改图中的设置\n\n从图中的按钮处可以进入如图的页面, 进入该页面后可以输入相关命令, 方便执行. 执行的话就点击执行就可以了. \n插件放在:\n&lt;bulid&gt;\n\t&lt;plugins&gt;\n\t\t&lt;plugin&gt;\n            &lt;!--插件放在这里--&gt;\n        &lt;&#x2F;plugin&gt;\n    &lt;&#x2F;plugins&gt;\n&lt;&#x2F;bulid&gt;\n\nweb项目的话, 用jetty(轻量级快速)或者tomcat插件\n在Maven中插件导入\n更改一下Maven中的配置\n在启动项选择中加入启动命令\n启动\n\n\n\n\n\n\n\n\n\n注意\n不行了, 跑步去了, 感觉要烂在椅子上了, 学习使我充实, 也使我疲倦. \n\n\n\n虽然已经是第二天了, 但是这是我既定的一天的学习内容, 所以仍然放在这篇博客. \nMaven仓库类型1. 中央仓库服务器在国外, 是Maven的主要仓库, 默认下载仓库\n2. 本地仓库下载完成之后就存放在本地仓库, 每一个本地项目都从本地仓库中找, 找不到就去中央仓库中下载\n3. 私服局域网中的仓库, 一般在公司中使用, 更快的下载Maven插件\n4. 其他仓库比如国内的阿里云镜像, 是中央仓库与私服的折中选择. \nMaven中创建子模块在父模块的目录上, 右键点击新模块. 而父模块的创建不需要选择Maven模板. \n\n实战实战传送门","slug":"Maven/Maven-Study-day01","date":"2022-11-11T08:41:35.000Z","categories_index":"Study","tags_index":"Maven","author_index":"Someone Serious"},{"id":"48f7fbdaf0e0dd4f6b63c39c2a27cf68","title":"springBoot-Study-day01","content":"先去学习Maven了, 真的和多米诺骨牌一样, 发现自己球也不懂.\n\n学完Maven和Spring的IOC了, 今天开始学习springBoot\nspringBoot是用来快速启动spring了, 解决了spring xml配置的繁琐和包文件的导入麻烦问题. \n\n\n\n\n\n\n提示\nSpringBoot不是对Spring的进一步强化, 而是对Spring的优化, 功能上没有多什么\n\n\n好了, G了, 还是要学Spring\nSSM框架-导学内容_哔哩哔哩_bilibili\n我心态崩了, 还要学tmd javaweb, javaweb又有三十四小时的课! 草了\n","slug":"springBoot/springBoot-Study-day01","date":"2022-11-11T08:23:35.000Z","categories_index":"Study","tags_index":"springBoot","author_index":"Someone Serious"},{"id":"307d6666c3d0b32790212432c57158e1","title":"RuoYi-frame-学习-day03","content":"\n\n\n\n\n\n\n特别注意\n今天不想学习, 只想摆烂, 接下来我要记录一下我打的几把联盟的战绩, 计算了一下, 从我第一天搭建博客, 到现在, 从上周五(4号)到今天, 已经猛干了五天了, 顶不住了. 我们要休息! 我们要争取八小时工作制!\n\n\n我莫甘娜追着豹女跑, 豹女硬顶着我的伤害把基地干爆了, TMD\n我已经放弃学习若依了, 选去搞springBoot","slug":"Ruoyi/RuoYi-frame-学习-day03","date":"2022-11-09T05:12:35.000Z","categories_index":"Study","tags_index":"RuoYi","author_index":"Someone Serious"},{"id":"95d3c68757bee3f9c7ba7e266dc65367","title":"RuoYi frame 学习 day01","content":"\n\n\n\n\n\n\n注意\n今天进入若依框架的学习, 为了天杀的实践课, 这个Guns是真该死啊\n\n首先我们需要一个传送门\n若依前后端分离版主要业务是权限管理系统, 简单易上手, 新手专用开源项目, 练手完美, 还有网课, 真是nice的不要不要的.\n首先就需要框架搭建若依传送门\n\n\n\n\n\n\n\n注意\n基础: SpringBoot + Vue\n\n真是草了, 算了springBoot之后再学, 先搞这个.\n所谓前后端分离, 当然要前端和后端分别打开\n要学的东西是真tmd多啊, 我还要搞\n\nmysql配置\nnavicat使用\nspringboot\nvue\n方便的插入图片\n\n至少第五点已经有解决方案了\n图片解决方案 -&gt; 传送门我感觉一切尽在掌握, 可是我该去吃饭了\n图片的问题已经解决了一半了通过导入插件的办法, 已经可以用如下的代码来解决图片插入的问题, 但是我们还要更换软件, 让插入图片更加舒畅.\n![](img1.png)\n\n我们就要用到 Typora 应用了, vscode 886.\n图片的问题解决了, 只不过最后要通过ctrl + f替换掉所有的题目&#x2F;\n\nmysql配置\n若依数据库配置\n设置url, 用户名,和密码, 说实话, 我这个数据库属实不太会用.\n除了需要配置mysql, 还需要配置Redis 它是另外一款数据库, 现在的我还不明白为什么需要两个数据库, 我现在博客写的这么意识流到底好不好啊?\n安装Redis还要用到虚拟机和Linux, 我的心态要崩了, 东西越学越多, 我真是操了.\nRedis Windows系统的管理器传送门\n还是得要在Linux上使用Redis真是草了, 但是今天的学习也就到这里了. 碎觉去了.\n\n现在已经第二天了, 但是鉴于昨天学的东西并不是很多, 所以我还是在这个post里继续写下去, 我在想是不是要另外开一个档用来存放干活而不是废话. 把这个当成学习日记算了, 这个Study分类就用来一边学习一边摸鱼吧. \n若依启动方式首先前后端都要打开前端就是ruoyi-ui 后端就是总项目里面的ruoyi-admin下面的RuoYiApplication\n启动后端前, 要先注意把数据库和redis都打开, redis启动就直接在resp中运行就可以了, 数据库在idea里面也可以启动. \n\nruoyi-ui下的src下的views下的index.vue是首页的内容. \n\n\n\n\n\n\n提示\n目录页面查找是通过数据库sys_menu来查找的, 里面有它的根目录\n\n\n\nEND今天只能学到这里了, 虽然说是一天, 但实际上是两天, 好啦 886\n","slug":"Ruoyi/RuoYi-frame-学习-day01","date":"2022-11-07T08:03:31.000Z","categories_index":"Study","tags_index":"RuoYi","author_index":"Someone Serious"},{"id":"a9e4774d724b74fc9dfb730280d107de","title":"Markdown Study day 02","content":"第二天起床再写今天晚上先把上传搞好\ntips: 明天改这个图像的BUG修改BUG日志: 好像好了, 又好像没好.\n起床啦建立表格我们需要用---来分割每列的标题, 然后用|来分割每列, 让我来试一下.\n\n\n\n正数\n负数\n0\n\n\n\n大于0的数\n小于0的数\n0\n\n\n|正数 | 负数 | 0 |\n|-----|------|--|\n|大于0的数|小于0的数|0|\n\n但是这样的代码又麻烦又丑, 于是我们必须要一个传送门  \n\n\n\n哺乳动物\n两栖动物\n爬行动物\n\n\n\n人类\n青蛙\n蜥蜴\n\n\n我的评价是, 还可以, 但不是太可以\n脚注不想学, 不好用\n标题编号tip: 我刚刚换了一个md的查看模组, 这个默认的模组很多语法都不识别.\n那么我这个标题编号的标题已经添加了标题编号方法如下\n## 标题编号\n\n    [Heading IDs](#heading-ids)\n\n然后就可以超链接过去了我把标题编号删了, 因为我发现系统会自动添加标题编号, 编号就是标题名称.链接到起床了感觉用起来还不错\n定义列表效果展示:  \n这是一个列表头: stuff1: stuff2stuff3这是下一个列表头: stuff1: stuff2stuff3这是一个列表头\n: stuff1\n: stuff2\n: stuff3\n\n这是下一个列表头\n: stuff1\n: stuff2\n: stuff3\n\n我的评价是: 捞的么淌口水\n删除线这个功能已经不被需要了, kill!\n~~这个功能已经不被需要了~~\n\n我很想知道快速创建代码块围栏的快捷键, 一个一个敲太麻烦了.装载了一个markdown shortcut 又有一堆指令要学习, 怎么感觉又麻烦了起来  !!!∑(ﾟДﾟノ)ノ\n任务列表语法- [x] Write the press release\n- [ ] Update the website\n- [ ] Contact the media\n\n\n Write the press release\n Update the website\n Contact the media\n\nmarkdown快捷键这里我想粘贴一张图片\n\n\n注意这里我没有使用markdown的语法, 我使用了hexo的语法\nhexo粘贴图片首先配置文件要先打开图片  \n_config.yml\npost_asset_folder: true\n\n然后把图片放在和post同名的文件夹下, 然后使用以下的命令\n&#123;% asset_img slug page1.png %&#125;\n&#x2F;&#x2F;注意, 这里的图片名字为 page1.png\n\n然后其他需要被引用到的元素都可以用hexo来解决解决的方法是通过传送门\n现在已经九点半了, 一会去上课, 晚上接着写这个GitHub的网络真的很不稳定\n上完课了, 晚上还要上选修课, 真tmd\n表情我觉得使用基本颜文字就可以了, 这个markdown表情感觉有点捞的不谈:imp::imp::imp:\n这里我们需要一张图片和一个传送门\n\n\n好啦! 这个markdown学完啦我们还可以继续学习这个模板的特殊语法语法很简单\n\n\n\n\n\n\n提示\n这是一个tip\n\n:::tip\n这是一个tip\n:::\n\n\n\n\n\n\n\n\n注意\n这是一个warning!!!\n\n:::warning\n这是一个warning!!!\n:::\n\n\n\n\n\n\n\n\n特别注意\n这是一个Danger!!!\n\n:::danger\n这是一个Danger!!!\n:::\n\n\nClick to see more\n点一个按钮可以看更多, 真是有够骚  \n\ndetails content\ndetails new line\n\nconsole.log(&#39;hello world&#39;)\n\n\n\n\n:::details Click to see more\n\ndetails\n\n- details content\n- details new line\n\n~~~javascript\nconsole.log(&#39;hello world&#39;)\n~~~\n\n:::\n\n\nEND结束了\nmarkdown就算彻底学完啦\n","slug":"mark/Markdown-Study-day-02","date":"2022-11-07T00:36:21.000Z","categories_index":"Study","tags_index":"Markdown","author_index":"Someone Serious"},{"id":"e9beb6261539d5bfbef19aa72e68381a","title":"Markdown Study day 01","content":"这是我的第一篇博客 (^▽^)进入Markdown学习众所周知Markdown是一款轻量级的语言，用于…后面的废话就不用说了，搞得跟真的一样。据说能在半个小时内掌握,我信他个鬼.(ｰ̀дｰ́)\n粘贴一个学习网址 https://markdown.com.cn/basic-syntax/\n\n使用标题就是通过前方加#的方式  \n # 一级标题\n## 二级标题\n### 三级标题\n\n段落前不要加双空格,没有用的,而且也没有必要(当然,我写这些有的没的tips其实还是在间接锻炼我的打字速度和使用Markdown的能力)\n\n换行可以加一个&lt;br&gt;或者加两个空格然后回车(注意区别换行和更换段落的区别)\n\n接下来是 粗体 与 斜体,至于又是粗体又是斜体,聪明的你应该已经猜到相应的语法了吧\n **粗体**\n*斜体*\n\n tips： 我现在的Markdown写的看起来非常的丑，但是估计之后会越写越好看，毕竟这是一个学习的过程。\n\n引用：\n\n\n\n\n\n\n\n\n\n今天真是他妈的学习的好日子，我终于可以狗娘养的学一天了 ————SomeoneSerious 2022.11.6\n &gt;引用，就这样写就可以了\n\n 注意我现在还不会引用缩进以及其他格式\n\n引用嵌套：\n\n\n\n\n\n\n\n\n\n这是一个父级引用\n\n这是一个子集引用\n\n &gt;这是一个父级引用\n&gt;&gt;这是一个子集引用\n\n 至于怎么让子级引用退回父级引用，我还不会。真tmd\n\n无序列表：\n 写到这里了，突然想放歌，至于我的博客为什么写的这么意识流，大概是因为没人看所以可以随心所欲吧。\n 大概效果是这样的\n\n我不知道该写点啥\n我还是不知道\n无所谓了\n换行\n牛不牛\n还能继续\n\n\n\n\n\n 这个地方的代码展示还有点困难。但是我会了(两个小时之后的我).\n * 我不知道该写点啥\n* 我还是不知道\n* 无所谓了\n    * 换行\n    * 牛不牛\n        * 还能继续\n\n代码块\n\n创建代码块就是通过搞四个空格就可以了（用软件的话一个tab &#x3D; 四个空格)  \n还可以使用围栏式的方法：\n\n 这是效果\n\n &#96;&#96;&#96;\n    这是代码\n    \\&#96;&#96;&#96;  没有前面的&quot;\\&quot;\n\n\n用 **`** 包围起来变量名或者其他代码名字，可以更加凸显，效果: createIdot()\n如果想用语法高亮的话，要再```后面加上这段语言的名字，试一下效果\n\n &#123;\n&#x2F;&#x2F; &#96;&#96;&#96;json\n&#x2F;&#x2F; code\n&#x2F;&#x2F; &#96;&#96;&#96;\n\n&#x2F;&#x2F; 这是我随便抄来的一段没有什么意义的代码，就是为了看看高亮。（被窝里看夜光手表）\n&quot;name&quot;: &quot;hexo-site&quot;,\n&quot;version&quot;: &quot;0.0.0&quot;,\n&quot;lockfileVersion&quot;: 2,\n&quot;requires&quot;: true,\n&#125;\n\n分割线\n\n就是通过使用***，就可以了\n\n\n\n上面就是一条分割线   \n\n 刚才改了一下中文输入时仍然用英文标点,不然实在是切换来切换去太麻烦了,\n\n超链接语法\n\n我觉得发明这种语言的人是一个天才, 在大家都追求个性的时候,通过这种单调的语言和单调的格式, 强行大大化减了办公难度, 我觉得这会成为一种趋势, (逗号后面得跟一个空格了, 因为现在在使用英文标点, tmd).就是现在一切都变得非常复杂, 就是为了应对人们刁钻的需求, 可是那些按钮大部分人一辈子也不会点一次, 但是缺经常能看到, 这是一件非常折磨的事情, 所以应该做一种应用定制, 而不是吃需求的大锅饭. 开发一款平台, 招募一大堆写脚本的程序员, 提出需求, 私人订制应用, 和跳蚤市场一样, 当人们有钱的时候, 这应该会是一个大市场.\n\n[超链接语法](https:&#x2F;&#x2F;markdown.com.cn)\n[Markdown语法](https:&#x2F;&#x2F;markdown.com.cn &quot;最好的markdown教程&quot;)。&#x2F;&#x2F;说实话, 这个 最好的教程 说的多少有点不要face.   \n\n\n效果Markdown语法感觉没p用\n其他\n\n&lt;尖括号里面写地址就是可以点的链接, 但是得写全&gt;\n\nhttps://www.baidu.com\n链接加粗加斜都是可以的, 还可以用 ` 加成标记code\n[&#96;code&#96;](&quot;https:&#x2F;&#x2F;www.baidu.com&quot;)\n[&#96;code&#96;](#code)\n\n睡觉去了, 睡半个小时起来再写.\n\n\n","slug":"mark/Markdown-Study-day-01","date":"2022-11-06T13:23:19.000Z","categories_index":"Study","tags_index":"Markdown","author_index":"Someone Serious"},{"id":"39367ba552a6a0ef310b797e6ac7a1d6","title":"inspiration","content":"像音乐一样的哲学\n\n\n\n\n\n提示\n于2022.11.7 夜 上选修课有感\n\n\n哲学应该像黑格尔的比喻一样, 重点不在于每一个音符, 而是每一个音符谱成的乐章, 这个乐章中的每个音符都参与到这个乐章中, 成为乐章中的一部分而不是杂音. 每一句都有道理的人不一定哲学素养高深, 他们的道理常常自相矛盾, 拾人牙慧, 哲学的重点在于体系, 成体系的, 流畅的, 自洽的, 完整的哲学体系, 就像一谱乐章一样. \n\n手套鼠标\n\n\n\n\n\n提示\n于2022.11.11午 看小视频有感\n\n\n你说, 把鼠标设计成手套的样子会不会很酷, 手套部分地方是固定的, 部分地方是活动的, 保持一个弓形, \n\n倒着走的时间\n\n\n\n\n\n提示\n于博客纪元之前玩 游戏新手指南时有感\n\n\n我们在时间的长河中不是面朝前注视着前方正向走的, 而是面朝后方倒退着走的, 我们只能看到过去, 每每回头展望未来时, 看到的都是虚影. 倒着走有一股强烈的不安感, 所以人们才会焦虑吧. \n\n焦虑与奋斗与躺平\n\n\n\n\n\n提示\n于2022.11.11 夜 在食堂回宿舍路上有感\n\n\n我到底是因为焦虑而躺平还是因为躺平而焦虑, 或者说躺平与奋斗谁能否医治我的焦虑, 奋斗到了瓶颈又怎么办, 在不断地运动中人才能得以慰藉吗, 一潭死水为什么会焦虑呢? 到底是我特殊还是世人大抵如此. \n\n暴力革命\n\n\n\n\n\n提示\n于博客纪元之前 知乎有感\n\n\n为什么历史上鲜有和平革命, 大部分都是流血暴动, 因为断人财路好似杀人父母, 杀父之仇不共戴天, 不流血干不成, 世界是分割的, 人不是理性的, 讲道理是讲不通的. \n\n当代互联网奇观\n\n\n\n\n\n提示\n于2022.11.5 中午与猪出去吃饭有感\n\n\n典急孝乐蚌赢麻寄\n\n","slug":"inspiration/inspiration","date":"2022-11-06T12:46:46.000Z","categories_index":"Other","tags_index":"","author_index":"Someone Serious"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo!\n\nclick there to know more\n this is my First blog, if you are here, it’s a pretty weired thing, because I never introduce people to this article, But if you find this, I will give you a gift. How to get it?\nCall me 叶良辰, you will get it.\n\n\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-11-06T12:27:47.711Z","categories_index":"","tags_index":"","author_index":"Someone Serious"}]
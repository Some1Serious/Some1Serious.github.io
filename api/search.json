[{"id":"57a77be283971411288f8bd127cf93cc","title":"Maven Skill 01","content":"自动填充get与set等方法lombok.data\n","slug":"Maven/Maven-Skill-01","date":"2022-12-08T14:33:11.000Z","categories_index":"Skill","tags_index":"Maven","author_index":"Someone Serious"},{"id":"45bc670afca0073bb4cc21c61b21c3c4","title":"javaWeb res CURD","content":"通过Mybatis, jsp,通过MVC架构实现增删改查\n1. 创建webapp骨架, 导入依赖, 以及tomcat&lt;!--myBatis的依赖--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;3.5.11&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;!--servlet的依赖--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;3.1.0&lt;&#x2F;version&gt;\n  &lt;scope&gt;provided&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;!--mysql驱动的依赖--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;8.0.29&lt;&#x2F;version&gt;\n\n&lt;&#x2F;dependency&gt;\n\n&lt;!--测试的依赖--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;4.13.2&lt;&#x2F;version&gt;\n  &lt;scope&gt;test&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n\n&lt;!--下面是jstl--&gt;\n\n&lt;dependency&gt;\n  &lt;groupId&gt;jstl&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;1.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n  &lt;groupId&gt;taglibs&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;standard&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;1.1.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n\n下面的内容不想再写了, 我花了一天的时间用jsp和mybatis写了一个增删改查的表格, 并把源代码上传到了我的github上面. \nSome1Serious&#x2F;myFirstCURD (github.com)\n","slug":"javaWeb/javaWeb-res-CURD","date":"2022-11-21T03:33:35.000Z","categories_index":"Result","tags_index":"javaWeb","author_index":"Someone Serious"},{"id":"77fc4926e9ec82b27aeede85a82bd4f7","title":"javaWeb res Login","content":"\n简述流程\n首先通过Tomcat创建服务器, 然后创建相应的网站页面, 这样我们可以访问网页\n创建数据库\n使用mybatis和mySql驱动, 创建存储类和Mapper\n创建servlet, 编写业务逻辑\n\n1. 创建webapp, Maven引入包从前台到后台, 我们一共需要以下的包&lt;!--myBatis的依赖--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;3.5.11&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;!--servlet的依赖--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;3.1.0&lt;&#x2F;version&gt;\n  &lt;scope&gt;provided&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;!--mysql驱动的依赖--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;8.0.30&lt;&#x2F;version&gt;\n\n&lt;&#x2F;dependency&gt;\n\n&lt;!--测试的依赖--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;4.13.2&lt;&#x2F;version&gt;\n  &lt;scope&gt;test&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n配置Tomcat传送门\n\n2. 创建Html文件&lt;div&gt;\n  &lt;h2&gt;登录&lt;&#x2F;h2&gt;\n&lt;!--  注意这里的相对路径--&gt;&lt;!--如果要写全的话, 从包路径开始写--&gt;\n  &lt;form action&#x3D;&quot;LoginCheckServlet&quot; method&#x3D;&quot;post&quot;&gt;\n\n    &lt;label&gt;\n      登录:  &lt;!--这里的name是我们日后调用的名字--&gt;\n      &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;userName&quot;&gt;\n    &lt;&#x2F;label&gt;&lt;br&gt;\n\n    &lt;label&gt;\n      密码:\n      &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot;&gt;\n    &lt;&#x2F;label&gt;&lt;br&gt;\n\n    &lt;input type&#x3D;&quot;submit&quot;&gt;\n\n\n\n  &lt;&#x2F;form&gt;\n&lt;&#x2F;div&gt;\n\n3. 创建数据库Create database LoLoginCheck;\nuse LoginCheck;\n\ndrop table if exists user;\ncreate table User(\n    id int primary key auto_increment,\n    username varchar(20) unique ,\n    password varchar(20)\n)\n\n添加数据\n4. 创建myBatis1. 在resources目录下, 创建mybatis配置文件(mybatis-config.xml)&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;\n\n&lt;configuration&gt;\n    &lt;environments default&#x3D;&quot;development&quot;&gt;\n        &lt;environment id&#x3D;&quot;development&quot;&gt;\n            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;\n            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n                &lt;!--修改数据库相关属性--&gt;\n                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;logincheck&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;Sxs12367&quot;&#x2F;&gt;\n            &lt;&#x2F;dataSource&gt;\n        &lt;&#x2F;environment&gt;\n    &lt;&#x2F;environments&gt;\n    &lt;mappers&gt;\n\n        &lt;!--        这是Mapperxml的导入--&gt;\n        &lt;!--这是导入包的方法, 写入一个包名, 自动扫描下面的配置--&gt;\n        &lt;package name&#x3D;&quot;com.myCompany.Mapper&quot;&#x2F;&gt;\n    &lt;&#x2F;mappers&gt;\n&lt;&#x2F;configuration&gt;\n\n2. 创建User存储类public class User &#123;\n\n    private int id;\n\n    private String userName;\n    private String password;\n\n后面get set方法就不写了\n3. 创建Mapper接口, 和配置文件\n\n\n\n\n\n提示\n要在同一个文件目录下\n\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n\n&lt;mapper namespace&#x3D;&quot;com.myCompany.Mapper.UserMapper&quot;&gt;\n    \n    &lt;!--用于同步数据库的名字和实体类的名字--&gt;\n    &lt;resultMap id&#x3D;&quot;UserResultMap&quot; type&#x3D;&quot;com.myCompany.pojo.User&quot;&gt;\n        &lt;!--        id用来完成主键字段的映射--&gt;\n        &lt;!--        &lt;id    --&gt;\n        &lt;!---用result完成一般映射--&gt;\n        &lt;result column&#x3D;&quot;username&quot; property&#x3D;&quot;userName&quot;&#x2F;&gt;\n    &lt;&#x2F;resultMap&gt;\n    \n    &lt;!--这里的id与接口中的方法名要一致--&gt;\n    &lt;select id&#x3D;&quot;checkIsRight&quot; resultMap&#x3D;&quot;UserResultMap&quot;&gt;\n        select *\n        from user\n        where username &#x3D; #&#123;userName&#125; and\n              password &#x3D; #&#123;password&#125;;\n    &lt;&#x2F;select&gt;\n&lt;&#x2F;mapper&gt;\n\npublic interface UserMapper &#123;\n\n    \n    User checkIsRight(@Param(&quot;userName&quot;)String userName, @Param(&quot;password&quot;)String password);\n\n\n&#125;\n\n4. 编写servlet方法:::warning\n下面的sqlSessionFactory会被重复创建, 因为以后可能要创建多个servlet, 所以我们要把它改成静态方法, Java-web-Study-day01\npackage com.myCompany.servlet;\n\nimport com.myCompany.Mapper.UserMapper;\nimport com.myCompany.pojo.User;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport javax.servlet.annotation.*;\nimport java.io.IOException;\nimport java.io.InputStream;\n&#x2F;&#x2F; 这里的要和页面中的action地址一致\n@WebServlet(value &#x3D; &quot;&#x2F;LoginCheckServlet&quot;)\npublic class LoginCheckServlet extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n\n        &#x2F;&#x2F;上面几行全是mybatis用于导入mapper的\n        String resource &#x3D; &quot;mybatis-config.xml&quot;;\n        InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);\n        SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);\n\n        SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();\n\n        &#x2F;&#x2F;得到mapper\n        UserMapper mapper &#x3D; sqlSession.getMapper(UserMapper.class);\n        &#x2F;&#x2F;------------------------------------------------------------------\n        \n        \n        &#x2F;&#x2F; 获取网页中的数据\n        String userName &#x3D; request.getParameter(&quot;userName&quot;);\n        String password &#x3D; request.getParameter(&quot;password&quot;);\n        \n        &#x2F;&#x2F;获取相应数据库中的数据\n        User user &#x3D; mapper.checkIsRight(userName, password);\n        \n        &#x2F;&#x2F;获取包路径\n        String contextPath &#x3D; request.getContextPath();\n        \n        &#x2F;&#x2F;业务逻辑判断\n        if (user !&#x3D; null)&#123;\n            response.sendRedirect(contextPath + &quot;&#x2F;afterLogIn&#x2F;success.html&quot;);\n        &#125;else &#123;\n            response.sendRedirect(contextPath + &quot;&#x2F;afterLogIn&#x2F;false.html&quot;);\n        &#125;\n        \n        &#x2F;&#x2F;记得关闭session\n        sqlSession.close();\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        request.setCharacterEncoding(&quot;UTF-8&quot;);\n        this.doGet(request, response);\n    &#125;\n&#125;\n\n最后的结构\n","slug":"javaWeb/javaWeb-res-Login","date":"2022-11-19T01:50:27.000Z","categories_index":"Result","tags_index":"javaWeb","author_index":"Someone Serious"},{"id":"8eebcf296ee2c092bcde72c4fe313aa5","title":"Vue study day02","content":"Vue 操作Dom通过ref回调的方式:\n&lt;script type&#x3D;&quot;module&quot;&gt;\nimport &#123; createApp &#125; from &#39;vue&#39;\n\ncreateApp(&#123;\n  &#x2F;&#x2F; ...\n  mounted()&#123;\n    this.$refs.p.textContent &#x3D; &#39;123&#39;\n  &#125;\n  \n&#125;).mount(&#39;#app&#39;)\n&lt;&#x2F;script&gt;\n\n&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;p ref&#x3D;&quot;p&quot;&gt;hello&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n\n如上面代码所示, ref表示p, 然后在creatApp中, 在mounted下, 通过这种方式修改他的textContent, 也就是他的dom属性之一\n\n监听数据变化Vue有监听数据变化然后产生副作用的功能, 具体代码如下:\n&lt;script type&#x3D;&quot;module&quot;&gt;\nimport &#123; createApp &#125; from &#39;vue&#39;\n\ncreateApp(&#123;\n  data() &#123;\n    return &#123;\n      todoId: 1,\n      todoData: null\n    &#125;\n  &#125;,\n  methods: &#123;\n    async fetchData() &#123;\n      this.todoData &#x3D; null\n      const res &#x3D; await fetch(\n        &#96;https:&#x2F;&#x2F;jsonplaceholder.typicode.com&#x2F;todos&#x2F;$&#123;this.todoId&#125;&#96;\n      )\n      this.todoData &#x3D; await res.json()\n    &#125;\n  &#125;,\n  \n  watch:&#123;\n    todoId(newId)&#123;\n      this.todoData.id &#x3D; newId\n    &#125;\n  &#125;,\n  \n  mounted() &#123;\n    this.fetchData()\n  &#125;\n&#125;).mount(&#39;#app&#39;)\n&lt;&#x2F;script&gt;\n\n&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;p&gt;Todo id: &#123;&#123; todoId &#125;&#125;&lt;&#x2F;p&gt;\n  &lt;button @click&#x3D;&quot;todoId++&quot;&gt;Fetch next todo&lt;&#x2F;button&gt;\n  &lt;p v-if&#x3D;&quot;!todoData&quot;&gt;Loading...&lt;&#x2F;p&gt;\n  &lt;pre v-else&gt;&#123;&#123; todoData &#125;&#125;&lt;&#x2F;pre&gt;\n&lt;&#x2F;div&gt;\n\n如上图的watch:, 它监听了todoId, 然后每次todoId发生改变之后, 他就会改变todoData.id.\n\n导入组件&lt;script type&#x3D;&quot;module&quot;&gt;\nimport &#123; createApp &#125; from &#39;vue&#39;\nimport ChildComp from &#39;.&#x2F;ChildComp.js&#39;\ncreateApp(&#123;\n  &#x2F;&#x2F; register child component\n  components: &#123;\n   ChildComp\n  &#125;\n&#125;).mount(&#39;#app&#39;)\n&lt;&#x2F;script&gt;\n\n先import组件, 然后在components:里面声明组件, 然后在html中使用, 注意使用时应遵循html命名规则\n&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;child-comp&gt;&lt;&#x2F;child-comp&gt;\n  &lt;!-- render child component --&gt;\n&lt;&#x2F;div&gt;\n\n\n父向子传递数据&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;child-comp :msg&#x3D;&quot;greeting&quot;&gt;&lt;&#x2F;child-comp&gt;\n&lt;&#x2F;div&gt;\n\n如上图, 注意, greeting已经在data里被定义过了, 然后在子组件中, 通过prop接受数据\nexport default &#123;\n  props: &#123;\n    msg: String\n  &#125;,\n  template: &#96;\n  &lt;h2&gt;&#123;&#123; msg || &#39;No props passed yet&#39; &#125;&#125;&lt;&#x2F;h2&gt;\n  &#96;\n&#125;\n\n","slug":"vue/Vue-study-day02","date":"2023-01-05T07:06:18.000Z","categories_index":"Study","tags_index":"Vue3.0","author_index":"Someone Serious"},{"id":"3961be608d49dc29dafdd30815d4f1d9","title":"Ajax Study day03","content":"前言这个地方的技术实在是太乱了, 根本不好搞, 真的很烦. \nAjax通过json返回请求JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。\nconst jsonStuff &#x3D; &#123;\n    count: x,\n    data: &quot;data&quot;,\n&#125;\nresponse.send(jsonStuff)\n\nconst jsonStuff &#x3D; JSON.parse(xhr.response)\n$(&#39;#result&#39;).html(jsonStuff.count+&quot;&lt;br&gt;&quot;+jsonStuff.data);\n\n上面的JSON把本来的字符串转化为JSON格式, 然后通过.来通过key获取相应的值\n也可以提前设置xhr的接受属性\nxhr.responseType &#x3D; &#39;json&#39;\n\n这样一劳永逸\n延时, 超时, 断网, 相关操作\n延时\nsetTimeout(function ()&#123;\n    response.send(&quot;两秒钟过去了&quot;)\n&#125;, 2000)\n\n设置超过一秒算超时\nxhr.timeout &#x3D; 1000;\nxhr.ontimeout &#x3D; function ()&#123;\n    $(&#39;#result&#39;).text(&quot;已经过了亿秒钟了&quot;)\n&#125;\n\n断网\nxhr.onerror &#x3D; function ()&#123;\n    $(&#39;#result&#39;).text(&quot;断网怎么说, 断网&quot;)\n&#125;\n\n终止\nxhr.abort()\n&#x2F;&#x2F;这里把shr的声明放到了外面, 是为了提高他的作用域, 这样我们才能终止\nlet xhr &#x3D; null;\n$(&#39;#abort&#39;).click(function ()&#123;\n    xhr.abort();\n    $(&#39;#result&#39;).text(&quot;断网怎么说, 断网&quot;)\n&#125;)\n\n重复发送请求问题万一有人犯癫痫, 一致发送重复请求, 这样服务器压力很大, 因为请求是需要时间的, 所以我们可以判断, 在请求时间内, 如果重复请求, 则忽略, 或者也可以忽略之前的请求, 重新发送请求, 总之保持一个请求. \n首先把flag定义在click方法外面\nlet flag &#x3D; false\n$(&#39;#getMessage&#39;).click(function ()&#123;\n\nif (!flag)&#123;\n    flag &#x3D; true\n    xhr &#x3D; new XMLHttpRequest();\n\n    xhr.onerror &#x3D; function ()&#123;\n        $(&#39;#result&#39;).text(&quot;断网怎么说, 断网&quot;)\n    &#125;\n    &#x2F;&#x2F;2:初始化, 设置请求方法和请求url\n    xhr.open(&#39;GET&#39;, &#39;http:&#x2F;&#x2F;localhost:8000&#x2F;delay&#39;)\n    &#x2F;&#x2F;3: 发送\n    xhr.send();\n\n    xhr.onreadystatechange &#x3D; function ()&#123;\n        if(xhr.readyState &#x3D;&#x3D;&#x3D; 4)&#123;\n\n\n            if (xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300)&#123;\n                const time2 &#x3D; Date.now();\n\n                $(&#39;#result&#39;).text(xhr.response).append(time2 - time)\n            &#125;\n            flag &#x3D; false\n        &#125;\n    &#125;\n&#125;else &#123;\n    return\n&#125;\n\n也可以重新发送\nif (flag)&#123;\n    xhr.abort();\n&#125;\n\nAjax与jQuery发送get与post请求$(&#39;#getMessage&#39;).click(function ()&#123;\n\n    &#x2F;&#x2F;参数: url json数据 回调函数(返回的数据)\n    $.get(&quot;http:&#x2F;&#x2F;localhost:8000&#x2F;jQuery&quot;, &#123;a:123, b:456&#125;, function (data)&#123;\n        $(&#39;#result&#39;).text(&quot;获取成功&quot;+data)\n    &#125;)\n&#125;)\n\n$(&#39;#getMessage2&#39;).click(function ()&#123;\n\n    &#x2F;&#x2F;参数: url json数据 回调函数(返回的数据)\n    $.post(&quot;http:&#x2F;&#x2F;localhost:8000&#x2F;jQuery&quot;, &#123;a:123, b:456&#125;, function (data)&#123;\n        $(&#39;#result&#39;).text(&quot;获取成功&quot;+data)\n    &#125;)\n&#125;)\n\napp.all(&quot;&#x2F;jQuery&quot;, function (request, response)&#123;\n    response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &quot;*&quot;)\n\n    setTimeout(function ()&#123;\n        response.send(&quot;123&quot;)\n    &#125;, 2000)\n\n&#125;)\n\n接受回传信息const data &#x3D; &#123;\n    car : &#39;fute&#39;,\n    money : &#39;800000000&#39;,\n\n&#125;\nsetTimeout(function ()&#123;\n    response.send(data)\n&#125;, 2000)\n\n$(&#39;#getMessage2&#39;).click(function ()&#123;\n\n    &#x2F;&#x2F;参数: url json数据 回调函数(返回的数据)\n    $.post(&quot;http:&#x2F;&#x2F;localhost:8000&#x2F;jQuery&quot;, &#123;a:123, b:456&#125;, function (data)&#123;\n        $(&#39;#result&#39;).text(&quot;获取成功&quot;+data.car)\n        console.log(data)\n    &#125;)\n&#125;)\n\n如果想自定义强的话, 可以使用jq的ajax请求, 几乎所有参数都可以更改调整, 具体可查jq的文档\nAxios当今最热门的操纵Ajax的东西, 我们可以在BootCDN下载镜像\n直接复制标签, 插进去就能用\nget与postaxios.defaults.baseURL &#x3D; &quot;http:&#x2F;&#x2F;localhost:8000&quot;\n\n$(&#39;#getMessage&#39;).click(function ()&#123;\n\n    &#x2F;&#x2F;get 参数:\n    axios.get(&#39;&#x2F;getSomething&#39;, &#123;\n        &#x2F;&#x2F;URL参数\n        params:&#123;\n            name:&#39;张三&#39;,\n            age:&quot;12&quot;,\n        &#125;,\n        &#x2F;&#x2F;设置请求头\n        headers:&#123;\n\n        &#125;,\n\n    &#125;).then(value &#x3D;&gt; &#123;\n        &#x2F;&#x2F;回调函数\n        console.log(value)\n    &#125;)\n\n&#125;)\n\n&#x2F;&#x2F;post的第二个参数是json的请求体, 第三个才是自定义\n$(&#39;#getMessage2&#39;).click(function ()&#123;\n    axios.post(&#39;&#x2F;postSomething&#39;, &#123;\n        firstName: &#39;Fred&#39;,\n        lastName: &#39;Flintstone&#39;\n    &#125;, &#123;\n        params: &#123;\n            \n        &#125;\n    &#125;)\n        .then(function (response) &#123;\n            console.log(response);\n        &#125;)\n&#125;)\n\n\n\n\n\n\n\n\n注意\n这里注意, 使用axios进行post请求的时候, 必须在请求端设置自定义请求头, 否则会报错\nres.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);\n\n\n\naxios&#x2F;&#x2F;自定义发消息, 具体api可查看文档\naxios(&#123;\n\n    url:&#39;&#x2F;postSomething&#39;,\n    method:&#39;post&#39;,\n    params:&#123;\n        id:&#39;10&#39;,\n        level:&#39;30&#39;\n    &#125;,\n    data:&#123;\n        name:&#39;张三&#39;\n    &#125;\n\n\n&#125;).then(value &#x3D;&gt; &#123;\n    console.log(value)\n&#125;)\n\n关于跨域问题ajax是不可以实现跨域的, 为了解决这个问题, 我们用jsonp, 他的实现原理是, script标签的请求是可以实现跨域的, 所以我们用script请求服务器, 但是服务器不能返回字符串, 而是要返回一个script能识别的代码, 通过代码实现双方的沟通. \n后记今天感觉有点划水, 本来想一天学完的东西, 结果还是得拖到明天上午留个尾巴, 感觉我的斗志已经慢慢下来了, 开始寄希望于未来了, 相信未来的我的智慧吧.\n","slug":"vue/Ajax-Study-day03","date":"2022-12-03T10:59:16.000Z","categories_index":"Study","tags_index":"Ajax","author_index":"Someone Serious"},{"id":"75dae5aac09587a263fe4e6ca350f17e","title":"Ajax Study day02","content":"前言看了几天这个CCF考试, 被折磨了, 又看了看若依, 又被折磨了, 一堆东西不会, 真TMD.\njQuery添加删除修改类jQuery可以控制元素的类, 我们通过类来控制元素的样式, 所以修改样式也就通过修改类来实现了.\n$(&#39;.box&#39;).click(function ()&#123;\n\n    &#x2F;&#x2F; 有就删除, 没有添加\n    $(this).toggleClass(&quot;clickBox&quot;)\n    &#x2F;&#x2F;添加\n    $(this).addClass(&quot;clickBox&quot;)\n    &#x2F;&#x2F;删除\n    $(this).removeClass(&quot;clickBox&quot;)\n\n&#125;)\n\n.box&#123;\n\n    background-color: wheat;\n    transition: all 0.5s;\n    margin: 0 auto;\n    text-align: center;\n&#125;\n\n.clickBox&#123;\n    background-color: red;\n    transform: rotate(360deg);\n&#125;\n\n用class更改和链式编程实现按钮功能:\n$(&#39;div.dropdown&#39;).click(function ()&#123;\n    $(this).toggleClass(&quot;dropdownClick&quot;).siblings().removeClass(&quot;dropdownClick&quot;)\n&#125;)\n\n贴一个api网址jQuery API 中文文档 | jQuery API 中文在线手册 | jquery api 下载 | jquery api chm (cuishifeng.cn)\n鼠标移入移出我们不必再用写两个方法来控制移入移出了, 一个方法就够了\n$(&#39;div.dropdown&#39;).hover(function ()&#123;\n    $(this).addClass(&quot;dropdownHover&quot;)\n&#125;, function ()&#123;\n    $(this).removeClass(&quot;dropdownHover&quot;)\n&#125;)\n\n还可以更简洁\n只写一个方法, 意味着移入移出都调用这个方法;\n\n\n\n\n\n\n提示\n在动画前加一个.stop()方法能阻止动画排队\n\n\n关于元素数据的存储与获取有三种方法\n获取修改固有数据console.log($(&quot;.list&quot;).prop(&quot;style&quot;));\n\n$(&quot;.list&quot;).prop(&quot;name&quot;, &quot;123&quot;);\nconsole.log($(&quot;.list&quot;).prop(&quot;name&quot;));\n\n自定义属性的修改与获取console.log($(&quot;.list&quot;).attr(&quot;index&quot;))\n&#x2F;&#x2F;undefined\n$(&quot;.list&quot;).attr(&quot;index&quot;, 5)\nconsole.log($(&quot;.list&quot;).attr(&quot;index&quot;))\n&#x2F;&#x2F;5\n\n\n\nAjaxAjax的特点在于它能实现不刷新页面的情况下实现与服务器的请求, 比如百度的关键词请求, 检测用户名是否存在, 显示二级分类, 懒加载(用则加载, 不用不加载), 新闻滚到底部加载新的内容. \n仍然使用的是js作为底板, 不是新的编程语言. \n缺点:\n没有浏览记录\n不可以跨域\nSEO(爬虫)不友好\n爬虫爬不到, 因为是异步请求的信息, 在源代码中并没有相关信息\n\n\n\nXML与html一样都是标签语言, 但是与html不同的是, 它没有预定义标签, 而且是用来传输数据和存储数据的, 但是现在基本用json了.\nHttp协议\n请求\n请求行\nURL\n请求方法\n…\n\n\n请求头\n键值对类型的数据\n\n\n空行\n请求体\n键值对类型的数据(只有post请求有请求体)\n在edge里的负载里\n\n\n\n\n响应\n响应行\nhttp类型\n状态(200 404)\n…\n\n\n响应头\n编码\n长度\n…\n\n\n空行\n响应体\nhtml\n其他数数据\n\n\n\n\n\nExpress基于node.js的极简web开发平台\nhelloworld\n新建立一个项目, 在终端输入:\nnpm init --yes\n\n首先要安装node.js\n\n导入包\nnpm i express\n\n输入代码\n&#x2F;&#x2F;引入对象\nconst express &#x3D; require(&#39;express&#39;)\n\n&#x2F;&#x2F;创建应用对象\nconst app &#x3D; express()\n\n&#x2F;&#x2F;创建路由规则\n\napp.get(&#39;&#x2F;&#39;, function (request, response)&#123;\n    response.send(&quot;helloWorld&quot;)\n&#125;)\n\n&#x2F;&#x2F;监听端口\n\napp.listen(8000, function ()&#123;\n    console.log(&quot;服务以启动&quot;)\n&#125;)\n\n启动\nPS C:\\Users\\Bincolo\\Desktop\\tmp\\Express\\src\\main\\webapp\\js\\helloworld&gt; \nnode .\\helloworldExpress.js\n\n\n利用Express写一个Ajax的简单程序用的jQuery\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;sendMessage&lt;&#x2F;title&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;..&#x2F;js&#x2F;jQ.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n\n&lt;style&gt;\n  #result&#123;\n    height: 500px;\n    width: 300px;\n    border: 2px solid black;\n  &#125;\n&lt;&#x2F;style&gt;\n\n&lt;body&gt;\n\n&lt;button id&#x3D;&quot;getMessage&quot;&gt;获取数据&lt;&#x2F;button&gt;\n&lt;div id&#x3D;&quot;result&quot;&gt;&lt;&#x2F;div&gt;\n\n&lt;&#x2F;body&gt;\n\n&lt;script&gt;\n\n    $(function ()&#123;\n        $(&#39;#getMessage&#39;).click(function ()&#123;\n\n            &#x2F;&#x2F;1:初始化创建对象\n            const xhr &#x3D; new XMLHttpRequest();\n            &#x2F;&#x2F;2:初始化, 设置请求方法和请求url\n            xhr.open(&#39;GET&#39;, &#39;http:&#x2F;&#x2F;localhost:8000&#x2F;sendMessage?a&#x3D;100&amp;b&#x3D;100&amp;c&#x3D;100&#39;)\n            &#x2F;&#x2F;3: 发送\n            xhr.send();\n\n            &#x2F;&#x2F;4:事件绑定. 处理服务器返回的结果\n            &#x2F;&#x2F;在xhr状态变化时, 会触发这个方法\n            &#x2F;&#x2F; 状态有五种, 按顺序为:\n            &#x2F;&#x2F; 0:未初始化, 1:创建对象, 2:初始化,3:发送请求\n            &#x2F;&#x2F;4:服务端返回的部分结果, 5:服务端返回的所有结果\n\n            xhr.onreadystatechange &#x3D; function ()&#123;\n                if(xhr.readyState &#x3D;&#x3D;&#x3D; 4)&#123;\n                    if (xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300)&#123;\n                        &#x2F;&#x2F;状态码\n                        console.log(xhr.status)\n                        &#x2F;&#x2F;状态字符串\n                        console.log(xhr.statusText)\n                        &#x2F;&#x2F;响应头\n                        console.log(xhr.getAllResponseHeaders())\n                        &#x2F;&#x2F;响应体\n                        console.log(xhr.response)\n\n                        $(&#39;#result&#39;).text(xhr.response)\n                    &#125;\n                &#125;\n            &#125;\n\n        &#125;)\n\n    &#125;)\n\n\n&lt;&#x2F;script&gt;\n&lt;&#x2F;html&gt;\n\n &#x2F;&#x2F;引入对象\nconst express &#x3D; require(&#39;express&#39;)\n\n&#x2F;&#x2F;创建应用对象\nconst app &#x3D; express()\n\n&#x2F;&#x2F;创建路由规则\nlet x &#x3D; 0\napp.get(&#39;&#x2F;sendMessage&#39;, function (request, response)&#123;\n    response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &quot;*&quot;)\n    x +&#x3D; 1\n    response.send(&quot;helloWorld&quot;+x)\n&#125;)\n\n&#x2F;&#x2F;监听端口\n\napp.listen(8000, function ()&#123;\n    console.log(&quot;服务以启动&quot;)\n&#125;)\n\n如何传参直接在url后面加就可以了\nxhr.open(&#39;GET&#39;, &#39;http:&#x2F;&#x2F;localhost:8000&#x2F;sendMessage?a&#x3D;100&amp;b&#x3D;100&amp;c&#x3D;100&#39;)\n\n\n\nnodemon一款可以自动帮忙重启express服务器的插件\nnpm install -g nodemon\n\n之后启动服务用nodemon\n","slug":"vue/Ajax-Study-day02","date":"2022-12-01T13:44:29.000Z","categories_index":"Study","tags_index":"Ajax,jQuery,Express","author_index":"Someone Serious"},{"id":"7995588ec8c84920145999cdc7166191","title":"Ajax Study day01","content":"前言摆烂了好久, 今天继续开始学习, 但是我觉得我学习的大头时间应该在寒假, 因为已经接近学期末了, 我也感觉时间不够用了, 这个学期压力确实大, 大的我头皮发麻. \njQuery19-jQuery\n基本不怎么用了, 但是还是学一点吧\n它是对XMLHttpRequest的一种封装, 也是对dom操作的封装, 这种封装其实都是在js语言的基础上写了一个js, 类似于java中的库, 让我们更好的使用他们.\n首先我们先要下载jQuery\nDownload jQuery | jQuery\n在dom文件加载完毕之后, 进行操作&lt;!--注意引入--&gt;\n&lt;script src&#x3D;&quot;js&#x2F;jQuery.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;body&gt;\n\n  &lt;a href&#x3D;&quot;&#x2F;CURD_war_exploded&#x2F;selectAllServlet&quot;&gt;查询所有&lt;&#x2F;a&gt;\n  &lt;div&gt;这是一个div, 当dom加载完毕之后就隐藏起来了&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n\n&lt;script&gt;\n    $(document).ready(function ()&#123;\n        $(&#39;div&#39;).hide();\n    &#125;)\n    &lt;!--下面是另外一种方法, 这两种方法效果一样--&gt;\n    $(function ()&#123;\n        $(&#39;div&#39;).hide();\n    &#125;)\n&lt;&#x2F;script&gt;\n\n$$符号是jQuery的顶层命名, 用来代指jQuary的.\n通过$获取的对象是jQuery对象, 通过原生js.document获取的对象是DOM对象, 两个是不一样的, jq对象经过了更多的包装, 有了更多的方法, 存储的形式也和DOM不同. \n所以:jQ对象只能使用jQ的方法和属性\n$(&#39;div&#39;).hide();\n\nconst d &#x3D; document.querySelector(&#39;div&#39;)\nd.style.display &#x3D; &quot;none&quot;\n\n所以聪明如你应该想到, 当jQ对象的操作不够时, 我们需要把它转换会js对象\njs与jQ转换const d &#x3D; document.querySelector(&#39;div&#39;);\n&#x2F;&#x2F; js转jq\n$(d);\n\n&#x2F;&#x2F;jq转js\n$(&#39;div&#39;).get(0).style.display &#x3D; &quot;none&quot;\n\n这里就应该注意到了, jq是伪数组形式存放数据的, 因为一个选择器可能提取出多个对象, 所以通过数组的形式存放, 我们通过get方法获取, 就是js对象.\n选择器这里我需要补充一下我之前选择器的欠缺知识\n&#x2F;&#x2F;类\n$(&#39;.a&#39;)\n&#x2F;&#x2F;元素\n$(&#39;div&#39;)\n&#x2F;&#x2F;id\n$(&#39;#id&#39;)\n\n\n\n\n\n\n\n提示\n定义类时我们可以通过空格让一个元素有多个类\n&lt;div class &#x3D; &quot;a b&quot;  &gt;这是一个div, 当dom加载完毕之后就隐藏起来了&lt;&#x2F;div&gt;\n\n\n\n&lt;div class &#x3D; &quot;father&quot;&gt;\n    &lt;div class &#x3D; &quot;child&quot;&gt;\n        这是子节点\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n\n\n&#x2F;&#x2F;同时包含a和b的元素\n$(&#39;.a.b&#39;).hide()\n&#x2F;&#x2F;通过中间间隔空格的方式获取子类\n$(&#39;.father .child&#39;).hide()\n\n取交集直接连接, 取并集用逗号连接\n&#x2F;&#x2F;交集\n$(&#39;.father#1&#39;).hide()\n&#x2F;&#x2F;并集\n$(&#39;.father,#1&#39;).hide()\n\n其他筛选器\n\n以下是方法, 不放在括号里, 而是调用方法.\n\n排他思想点击一个方块, 其他方块颜色变回原色, 这个方块变成黑色:\n$(function ()&#123;\n\n    $(&#39;div.dropdown&#39;).click(function ()&#123;\n        $(this).css(&#39;background&#39;,&#39;black&#39;)\n        $(this).css(&#39;color&#39;,&#39;white&#39;)\n        \n        &#x2F;&#x2F;siblings是选取兄弟元素, 并且类为dropdown\n        $(this).siblings(&#39;.dropdown&#39;).css(&#39;background&#39;,&#39;#f9f9f9&#39;)\n        $(this).siblings(&#39;.dropdown&#39;).css(&#39;color&#39;,&#39;black&#39;)\n    &#125;)\n\n&#125;)\n\n常用APIcss&#x2F;&#x2F; jq.css(属性, 值)\n$(&#39;div&#39;).css(&quot;background&quot;, &quot;pink&quot;)\n&#x2F;&#x2F;如果只写属性名, 则返回属性值\nconst v &#x3D; $(&#39;div&#39;).css(&quot;background&quot;)\n\n&#x2F;&#x2F;可以同时更改多个, 更改多个时不用加引号\n$(this).css(&#123;\n    &#x2F;&#x2F;符合属性要用驼峰命名法\n    backgroundColor: &#39;black&#39;,\n    color: &#39;white&#39;\n&#125;)\n\n注意这里的隐式迭代, 获得的是所有div组成的数组, 这里封装了for循环的方法, 所以看起来没有循环, 其实已经循环遍历更改的.\n下标的使用鼠标放在哪一个方块上, 就显示哪一个方块的下标\n$(function ()&#123;\n\n    $(&#39;div.dropdown&#39;).mouseover(function ()&#123;\n        let index &#x3D; $(this).index()\n        $(&#39;.show&#39;).text(index)\n    &#125;)\n\n&#125;)\n\n\n实例元素的隐藏与出现当鼠标移上去的时候, 元素出现, 否则元素不可见\n$(function ()&#123;\n    \n    &#x2F;&#x2F; 这里不能用display, 或者visibility等属性, 因为他们不可见了之后也不能操作了, 我们用\n    &#x2F;&#x2F;透明度让文件不可见\n    \n    $(&#39;.dropdown&#39;).mousemove(function ()&#123;\n        $(this).css(&quot;opacity&quot;, 100)\n    &#125;)\n    $(&#39;.dropdown&#39;).mouseout(function ()&#123;\n        $(this).css(&quot;opacity&quot;, 0)\n    &#125;)\n&#125;)\n\n这里的$(this)指本身.\n$.get()\n\n\n\n\n\n提示\n图中的中括号意味着这个参数是可选的\n\n\n\n\n\n\n\n\n\n提示\nAjax的请求在F12里面的XHR里面查看\n\n\n","slug":"vue/Ajax-Study-day01","date":"2022-11-29T12:56:17.000Z","categories_index":"Study","tags_index":"Ajax,jQuery","author_index":"Someone Serious"},{"id":"e5cc21b95785d4fffff0ff216425205d","title":"Vue study day01","content":"Vue HelloWorld\n导入Vue的包\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;\n\n在script里面编写相关代码\n&lt;script&gt;\n    var app &#x3D; new Vue(&#123;\n        el:&quot;#app&quot;,\n        data:&#123;\n            message:&quot;heima&quot;\n        &#125;\n    &#125;)\n  &lt;&#x2F;script&gt;\t\n\n作用范围\n&lt;!--app标签下, 可作用--&gt;    \n&lt;div id&#x3D;&quot;app&quot;&gt;&#123;&#123; message &#125;&#125;\n\t\t&lt;!--标签内部, 可作用--&gt;\n        &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n&lt;!--外部, 不可作用--&gt;\n    &#123;&#123; message &#125;&#125;\n\n不要挂在body上, 挂在div上最好, 挂在其他双标签也可以支持.\n\n\nVue存储的各种数据类型var app &#x3D; new Vue(&#123;\n    el:&quot;#app&quot;,\n    data:&#123;\n        message:&quot;heima&quot;,\n        User:&#123;\n            &quot;name&quot;:&quot;123&quot;,\n            &quot;age&quot;:&quot;12&quot;,\n            &quot;school&quot;:&quot;小学&quot;\n        &#125;,\n        list:[&quot;一&quot;,&quot;二&quot;,&quot;三&quot;]\n        \n    &#125;\n&#125;)\n\n&lt;div id&#x3D;&quot;app&quot;&gt;\n\n    &lt;div&gt;\n        message:&#123;&#123; message &#125;&#125;&lt;br&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;div&gt;\n        username:&#123;&#123; User.name &#125;&#125;&lt;br&gt;\n        userage: &#123;&#123;User.age&#125;&#125;&lt;br&gt;\n        user:&#123;&#123;User&#125;&#125;\n    &lt;&#x2F;div&gt;\n\n    &lt;div&gt;\n        list:&#123;&#123;list&#125;&#125;&lt;br&gt;\n        list[0]:&#123;&#123;list[0]&#125;&#125;\n    &lt;&#x2F;div&gt;\n    \n&lt;&#x2F;div&gt;\n\nVue指令\n字符串拼接+ v-text, v-html\n&lt;div&gt;\n    message:&#123;&#123; message +&#39;!!!&#39;&#125;&#125;&lt;br&gt;\n&lt;&#x2F;div&gt;\n\n&lt;h1 v-text &#x3D;&#39;message&#39;&gt;&lt;&#x2F;h1&gt;\t\n\n聪明如你应该知道, 这个html与text的差别在于, html能渲染html指令. \n&lt;div&gt;\nmessage:&#123;&#123; message +&#39;!!!&#39;&#125;&#125;&lt;br&gt;\n&lt;&#x2F;div&gt;\n\n&lt;h1 v-html &#x3D;&#39;message&#39;&gt;&lt;&#x2F;h1&gt;\n\n\n\n\n\n我又来开始学习Vue啦今天是2023.1.4，我已经很久没有学习了，因为我花了半个月的时间学完了一个学期的内容，加上各种各样的期末作业，现在我也是为了完成web的期末作业，做一个招聘展示页面。\n我的学习路径是vue3里面的基础教程下面是一些我对vue的理解：\n对于属性的动态绑定&lt;script type&#x3D;&quot;module&quot;&gt;\nimport &#123; createApp &#125; from &#39;vue&#39;\n\ncreateApp(&#123;\n  data() &#123;\n    return &#123;\n      titleClass: &#39;title&#39;\n    &#125;\n  &#125;\n&#125;).mount(&#39;#app&#39;)\n&lt;&#x2F;script&gt;\n\n&lt;div id&#x3D;&quot;app&quot;&gt;\n    &#x2F;&#x2F;全称为v-bind:class，下面是简称\n  &lt;h1 :class&#x3D;&quot;titleClass&quot;&gt;Make me red&lt;&#x2F;h1&gt;\n&lt;&#x2F;div&gt;\n\n上面这一段代码，作用是把h1的class动态绑定到titleClass里面去了，这样我们可以再data()中修改属性。\n对于元素内部的修改&lt;script type&#x3D;&quot;module&quot;&gt;\nimport &#123; createApp &#125; from &#39;vue&#39;\n\ncreateApp(&#123;\n  data() &#123;\n    return &#123;\n      &#x2F;&#x2F;注意这里是冒号\n      count: 0,\n      color:123\n    &#125;\n  &#125;,\n  methods:&#123;\n    increase()&#123;\n      this.count++,\n        &#x2F;&#x2F;注意，这里是等于\n      this.color&#x3D; &#39;red&#39;\n    &#125;\n  &#125;\n&#125;).mount(&#39;#app&#39;)\n&lt;&#x2F;script&gt;\n\n&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;!-- 使此按钮生效 --&gt;\n  &lt;button @click&#x3D;&quot;increase&quot;&gt;count is: &#123;&#123; count &#125;&#125; &#123;&#123; color &#125;&#125;&lt;&#x2F;button&gt;\n&lt;&#x2F;div&gt;\n\n上面的代码, methods是保留字, 里面的increase是自定义的名字, 在下面的button里面被调用, 通过**this.**能调用这个元素里面的&#123;&#123;&#125;&#125;内容\n对于input框的绑定&lt;input :value&#x3D;&quot;text&quot; @input&#x3D;&quot;onInput&quot;&gt;\n\n我们需要绑定两个值:一个是它的类型, 一个是它的方法\n方法的调用:\nmethods: &#123;\n  onInput(e) &#123;\n    &#x2F;&#x2F; v-on 处理函数会接收原生 DOM 事件\n    &#x2F;&#x2F; 作为其参数。\n    this.text &#x3D; e.target.value\n  &#125;\n&#125;\n\n但是我们还有一步到位的方法:\n&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;input v-model&#x3D;&quot;text&quot; placeholder&#x3D;&quot;Type here&quot;&gt;\n  &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n\n这样会实现自动绑定, 就是说input的值会在text中, 而下面的text的值也会调用text.\n条件渲染v-if, v-else, v-else-if\n在标签中使用这个函数\n&lt;h1 v-if&#x3D;&quot;awesome&quot;&gt;Vue is awesome!&lt;&#x2F;h1&gt;\n\n效果就是:\n当awesome为true的时候展现, 否则消失\nawesome在方法中用this.调用\nmethods: &#123;\n  toggle() &#123;\n    this.awesome &#x3D; ! this.awesome\n    &#x2F;&#x2F; ...\n\t\n  &#125;\n&#125;\n\n在data()中赋初值\n列表渲染用v-for,可以循环渲染,具体代码如下:\n&lt;script type&#x3D;&quot;module&quot;&gt;\nimport &#123; createApp &#125; from &#39;vue&#39;\n\n&#x2F;&#x2F; 给每个 todo 对象一个唯一的 id\nlet id &#x3D; 0\n\ncreateApp(&#123;\n  data() &#123;\n    return &#123;\n      newTodo: &#39;&#39;,\n      todos: [\n        &#123; id: id++, text: &#39;Learn HTML&#39; &#125;,\n        &#123; id: id++, text: &#39;Learn JavaScript&#39; &#125;,\n        &#123; id: id++, text: &#39;Learn Vue&#39; &#125;\n      ]\n    &#125;\n  &#125;,\n  methods: &#123;\n    addTodo() &#123;\n      this.todos.push(&#123; id: id++, text: this.newTodo &#125;)\n      this.newTodo &#x3D; &#39;&#39;\n    &#125;,\n    removeTodo(todo) &#123;\n      this.todos &#x3D; this.todos.filter((t) &#x3D;&gt; t !&#x3D; todo)\n    &#125;\n  &#125;\n&#125;).mount(&#39;#app&#39;)\n&lt;&#x2F;script&gt;\n\n&lt;div id&#x3D;&quot;app&quot;&gt;\n  &lt;form @submit.prevent&#x3D;&quot;addTodo&quot;&gt;\n    &lt;input v-model&#x3D;&quot;newTodo&quot;&gt;\n    &lt;button&gt;Add Todo&lt;&#x2F;button&gt;    \n  &lt;&#x2F;form&gt;\n  &lt;ul&gt;\n    &lt;li v-for&#x3D;&quot;todo in todos&quot; :key&#x3D;&quot;todo.id&quot;&gt;\n      &#123;&#123; todo.text &#125;&#125;\n      &lt;button @click&#x3D;&quot;removeTodo(todo)&quot;&gt;X&lt;&#x2F;button&gt;\n    &lt;&#x2F;li&gt;\n  &lt;&#x2F;ul&gt;\n&lt;&#x2F;div&gt;\n\n这里我们循环时用了:key元素, 该元素是用来渲染时排序的, 所以一定要唯一\n这里还使用了js对数组的操作, push用于在末尾添加元素, 而filter用于删除指定的元素, 它是要求传入一个函数, 该函数有一个参数, 就是对列表的遍历的元素, 删除返回为false的元素.\n计算属性计算属性是每次计算之后才会输出的一种数据\ncomputed: &#123;\n  filteredTodos() &#123;\n    return this.hideCompleted\n      ? this.todos.filter((t) &#x3D;&gt; !t.done)\n      : this.todos\n  &#125;\n&#125;,\n\n方法里面的返回值是一个数组(todos), 所以我们引用filteredTodos的时候也是一个数组:\n&lt;li v-for&#x3D;&quot;todo in filteredTodos&quot; :key&#x3D;&quot;todo.id&quot;&gt;\n\n","slug":"vue/Vue-study-day01","date":"2022-11-24T09:07:18.000Z","categories_index":"Study","tags_index":"Vue2.0","author_index":"Someone Serious"},{"id":"2e2d2f7787fd4b06e89c4750d1f53cf7","title":"Java web Study day03","content":"Filter\n\n\n\n\n注意, 是按照类名的字典排序.\n\nFilter登陆拦截","slug":"javaWeb/Java-web-Study-day03","date":"2022-11-23T06:03:10.000Z","categories_index":"Study","tags_index":"javaWeb","author_index":"Someone Serious"},{"id":"1fc16d3409aad120eec2a8ea1680d7e7","title":"Java web Study day02","content":"MVC 和三层架构\n\n\n\n\n\n\n\n提示\n我们说的SSM就是上面这三个框架\n\n\n\n\nTomcat热部署idea配置tomcat热部署_qq_41288095的博客-CSDN博客_idea配置tomcat热部署\n\n关于Idea创建不了servlet的问题\n\n\nCookie\n创建cookie\nCookie cookie &#x3D; new Cookie(&quot;myFirstCookie&quot;, &quot;HAHAHA&quot;);\nresponse.addCookie(cookie);\n\n获得cookie\nCookie[] cookies &#x3D; request.getCookies();\n\nfor (Cookie cookie : cookies) &#123;\n\n    System.out.println(&quot;key:&#39;&quot;+cookie.getName()+&quot;&#39;, value:&#39;&quot;+cookie.getValue()+&quot;&#39;\\n&quot;);\n\n&#125;\n\n获得的是一个数组, 可以分别得到他的键值对, 类型都是String型\ncookie在jsp中获取\n\n存活时间与存储中文问题\n&#x2F;&#x2F;存储中文要编码\nString value &#x3D; &quot;哈哈哈&quot;;\nString encode &#x3D; URLEncoder.encode(value, &quot;utf-8&quot;);\n\nCookie cookie &#x3D; new Cookie(&quot;myFirstCookie&quot;, encode);\n\n&#x2F;&#x2F;存放一周\ncookie.setMaxAge(60*60*24*7);\nresponse.addCookie(cookie);\n\nCookie[] cookies &#x3D; request.getCookies();\n\nfor (Cookie cookie : cookies) &#123;\n\n    if(cookie.getName().equals(&quot;myFirstCookie&quot;))&#123;\n        &#x2F;&#x2F;得到数据之后再解码\n        System.out.println(&quot;key:&#39;&quot;+cookie.getName()+&quot;&#39;, value:&#39;&quot;+URLDecoder.decode(cookie.getValue(), &quot;utf-8&quot;)+&quot;&#39;\\n&quot;);\n        break;\n    &#125;\n\n\n&#125;\n\n\n\n\n\n\n\n提示\ncookie的key不能重复, 会覆盖\n\n\nSession\n注意, 这里的session存放的数据是任意类型. 这是与cookie不同的地方. \n\n\n\n\n\n\n提示\nsession是基于cookie实现的, 它保证每个浏览器对应一个唯一的session的方法是:\n当一个浏览器访问网站时, 服务器向浏览器中存放一个cookie键值对, 值就是那个session的唯一标识, 所以只要用这个浏览器访问页面, 它就会得到唯一对应的session. 但是浏览器关闭了, 对应的session就没了\n\n\n\nCookie与Session\n\nequals防止空指针异常String x &#x3D; &quot;2&quot;;\n&#x2F;&#x2F;直接使用可能会空指针异常, 因为x可能为空\nx.equals(&quot;2&quot;);\n&#x2F;&#x2F;所以我们这样写\n&quot;2&quot;.equals(x);\n\n\n关于请求刷新我想重复请求一个图片(验证码), 我就可以在图片上添加一个单击事件, 每次一点击图片, 就更新图片的src地址, 地址指向的是获得图片的servlet, 但是这样浏览器会因为缓存问题, 不访问服务器而是直接使用缓存, 所以我们需要在请求后面添加参数, 把时间当做参数, 保证参数永远不会重复. \n\n","slug":"javaWeb/Java-web-Study-day02","date":"2022-11-20T14:03:59.000Z","categories_index":"Study","tags_index":"javaWeb,MVC,Cookie","author_index":"Someone Serious"},{"id":"d4a56035763a2a8e516ae03b6a6591a1","title":"Css Skill 01","content":"刷新问题有时更改了css但是浏览器缺不更新, 原因是缓存, 我们需要ctrl + f5进行刷新就可以了.\n如果还不行的话, 就请求禁用缓存, 应该就行了\n\n\n新手指南CSS Cheat Sheet - Interactive, not a PDF | HTMLCheatSheet.com\n","slug":"HtmlCssJs/Css-Skill-01","date":"2022-11-20T03:23:42.000Z","categories_index":"Skill","tags_index":"css","author_index":"Someone Serious"},{"id":"6874dacf7173c2e0b3c898051819a0ee","title":"Tomcat Servlet study day02","content":"Request与ResponseRequest是用来获取请求数据\nResponse是用来相应数据的\n现在已经十一点半了, 已经学不动了, 从下午一点开始一直学到晚上十一点半, 拉磨的驴都受不了. \nrequest1. 请求行\ntomcat解析传递信息, 封装到它创建的request中, 然后传入serves方法中, 给我们调用. \n\n@WebServlet(urlPatterns &#x3D; &#123;&quot;&#x2F;MyHttpServlet1&quot;, &quot;&#x2F;MyHttpServlet2&quot;&#125;)\npublic class MyHttpServlet extends HttpServlet &#123;\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\n\n        &#x2F;&#x2F;返回请求的方式\n        String method &#x3D; req.getMethod();\n        System.out.println(&quot;method:&quot; + method);\n\n\n        &#x2F;&#x2F; 返回项目访问的路径\n        String contextPath &#x3D; req.getContextPath();\n        System.out.println(&quot;contextPath:&quot; + contextPath);\n\n        &#x2F;&#x2F;获取相对路径\n        String requestURI &#x3D; req.getRequestURI();\n        System.out.println(&quot;requestURI:&quot; + requestURI);\n\n        &#x2F;&#x2F;获取这个URL\n        StringBuffer requestURL &#x3D; req.getRequestURL();\n        System.out.println(&quot;requestURL:&quot; + requestURL.toString());\n\n        &#x2F;&#x2F;获取GET方法的数据, 我们可以用split切割获取键值对 数据存放在地址?后面, 用&amp;分割\n        String queryString &#x3D; req.getQueryString();\n        System.out.println(&quot;queryString:&quot; + queryString);\n\n\n    &#125;\n\nmethod:GET\ncontextPath:&#x2F;myTomcat_war\nrequestURI:&#x2F;myTomcat_war&#x2F;MyHttpServlet1\nrequestURL:http:&#x2F;&#x2F;localhost:8080&#x2F;myTomcat_war&#x2F;MyHttpServlet1\nqueryString:null\n\nmethod:GET\ncontextPath:&#x2F;myTomcat_war\nrequestURI:&#x2F;myTomcat_war&#x2F;MyHttpServlet1\nrequestURL:http:&#x2F;&#x2F;localhost:8080&#x2F;myTomcat_war&#x2F;MyHttpServlet1\nqueryString:hello&#x3D;123&amp;qwe&#x3D;456\n\n2. 请求头\nString header &#x3D; req.getHeader(&quot;User-Agent&quot;);\nSystem.out.println(&quot;header:&quot; + header);\n\nheader:Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;107.0.0.0 Safari&#x2F;537.36 Edg&#x2F;107.0.1418.42\n\n3. 请求体\n要在post方法中才能调用, 我们要先写一个关于post请求的html页面. \n&lt;!-- 注意这里的action设置前面没哟&#39;&#x2F;&#39;, 这样会显示相对路劲, 相对于当前项目 --&gt;\n&lt;form action&#x3D;&quot;MyHttpServlet1&quot; method&#x3D;&quot;post&quot;&gt;\n    &lt;label&gt;\n        123\n        &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt;\n    &lt;&#x2F;label&gt;\n    &lt;label&gt;\n        &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;password&quot;&gt;\n    &lt;&#x2F;label&gt;\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;submit&quot;&gt;\n&lt;&#x2F;form&gt;\n\n在servlet实现类中:\n@Override\nprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\n    &#x2F;&#x2F;通过输入流来输入数据, 我们不需要手动关闭输入流, 因为req会被自动关闭\n    BufferedReader reader &#x3D; req.getReader();\n    String s &#x3D; reader.readLine();\n    System.out.println(s);\n\n&#125;\n\nres:\nusername&#x3D;name&amp;password&#x3D;pwd\n\n4.获取请求数据聪明如你也应该想到, 上面这种数据获取方式谁要啊, 我们想要的状态是直接获取一个字典, 然后通过键值对直接获取数据, 这个当然也是可以的. 方法如下:\n\n\n\n\n\n\n提示\nidea输入iter可以快速写遍历函数\n\n\n处理了一个jsp网页乱码的问题, 我们在jsp页面头部加上相关编码信息\n&lt;%@ page language&#x3D;&quot;java&quot; contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot; pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;\n\n\n\n\n\n\n\n\n\n特别注意\n这里有一个没有处理的问题, checkbox的value值为中文时, 传输回java会报乱码\n已经解决了, tomcat8及以上的版本就用下面的方法post与get方法都可以处理, 如果是之前的版本则再用其他方式处理. \nreq.setCharacterEncoding(&quot;UTF-8&quot;);\n\n\n\n\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\n        &#x2F;&#x2F;通过输入流来输入数据, 我们不需要手动关闭输入流, 因为req会被自动关闭\n        &#x2F;&#x2F; 这是得到字典的方法, 因为有checkbox的存在, 所以是name对应一个value数组\n        Map&lt;String, String[]&gt; parameterMap &#x3D; req.getParameterMap();\n        for (String key : parameterMap.keySet()) &#123;\n            System.out.println(key + &quot;:&quot; + Arrays.toString(parameterMap.get(key)));\n        &#125;\n        \n        &#x2F;&#x2F; 如果知道传入是一个数组, 这样单拿\n        String[] hobbies &#x3D; req.getParameterValues(&quot;hobby&quot;);\n        for (String hobby : hobbies) &#123;\n            System.out.println(hobby);\n        &#125;\n        \n        &#x2F;&#x2F;单取非数组\n        String username &#x3D; req.getParameter(&quot;username&quot;);\n        System.out.println(username);\n\n    &#125;\n&#125;\n\n\n\n\n\n\n\n提示\n这里的方法, 在get与post中就统一了, 所以我们可以这么写\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\t\t\n        &#x2F;&#x2F;使用字典或者单值获取的方式, 做到get与post统一\n\t\t&#x2F;&#x2F;....\n\n\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\t\t\n        &#x2F;&#x2F; 直接调用\n        doGet(req, resp);\n    &#125;\n&#125;\n\n\n\n\n4. 请求转发当服务器来一个请求的时候, 我们可以把请求转发到另外一个servlet里面去, 当然, servlet之间也可以共享资源, 通过把资源附加在request里面的方式\n\n下面是实例代码:\n@WebServlet(&quot;&#x2F;MyHttpServlet1&quot;)\npublic class MyHttpServlet extends HttpServlet &#123;\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\n\n\n        System.out.println(&quot;我们已经执行了servlet一号里面的内容&quot;);\n\n        &#x2F;&#x2F;向req里面添加了一些内容, 通过字典的方式, key:string, value:Object\n        req.setAttribute(&quot;something&quot;, &quot;the value&quot;);\n\n        &#x2F;&#x2F;跳转到&#x2F;MyHttpServlet2去执行相应的servlet代码, 调用的是get方法\n        req.getRequestDispatcher(&quot;&#x2F;MyHttpServlet2&quot;).forward(req, resp);\n\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\n        req.setCharacterEncoding(&quot;UTF-8&quot;);\n        this.doGet(req, resp);\n    &#125;\n&#125;\n\n另一个类:\n@WebServlet(&quot;&#x2F;MyHttpServlet2&quot;)\npublic class MyHttpServlet2 extends HttpServlet &#123;\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\n        System.out.println(&quot;this is get, run on MyHttpServlet2&quot;);\n\n        Object something &#x3D; req.getAttribute(&quot;something&quot;);\n        System.out.println(&quot;something:&quot; + something.toString());\n\t\t      \n        &#x2F;&#x2F;可以删掉相应的键值对\n        req.removeAttribute(&quot;something&quot;);\n\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\n        System.out.println(&quot;this is post...&quot;);\n        req.setCharacterEncoding(&quot;UTF-8&quot;);\n        this.doGet(req, resp);\n    &#125;\n&#125;\n\nResponse\n1. 重定向\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\n\n\n        System.out.println(&quot;我们已经执行了servlet一号里面的内容&quot;);\n\n&#x2F;&#x2F;        &#x2F;&#x2F;可以直接执行系统外部的网站\n&#x2F;&#x2F;        resp.sendRedirect(&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;);\n\n        &#x2F;&#x2F;注意, 这里要写项目名, 我们通过请求头获取项目名, 降低耦合\n        String contextPath &#x3D; req.getContextPath();\n        System.out.println(contextPath);\n        resp.sendRedirect(contextPath + &quot;&#x2F;MyHttpServlet2&quot;);\n\n    &#125;\n\n2. 相应字符字节数据\n字符\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\n\n\n        System.out.println(&quot;我们已经执行了servlet一号里面的内容&quot;);\n        resp.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);\n        &#x2F;&#x2F;因为writer会在response结束之后结束掉, 所以所以我们没有必要手动关闭writer\n        PrintWriter writer &#x3D; resp.getWriter();\n\n&#x2F;&#x2F;        &#x2F;&#x2F;设置回复头, 设置回复的数据是html数据\n&#x2F;&#x2F;        resp.setHeader(&quot;content-type&quot;, &quot;text&#x2F;html&quot;);\n        &#x2F;&#x2F;上面这种设置方法我们不用, 我们用下面的设置方法, 能同时更改编码, 避免乱码的问题\n\n\n        &#x2F;&#x2F;我们可以写一些字符, 但是输入中文仍然会报错, 我们需要更改编码\n        writer.write(&quot;中文&quot;);\n\n        writer.write(&quot;&lt;h1&gt;中文&lt;&#x2F;h1&gt;&quot;);\n    &#125;\n\n字节\n当我们输入一些图片视频文件信息时, 我们需要字节输入. \n\n\n\n\n\n\n提示\n这里我们建议使用commons-io\n&lt;dependency&gt;\n  &lt;groupId&gt;commons-io&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;commons-io&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;2.11.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n        &#x2F;&#x2F;创建文件流和输出流\n        FileInputStream fileInputStream &#x3D; new FileInputStream(&quot;C:\\\\Users\\\\Bincolo\\\\Desktop\\\\1.doc&quot;);\n&#x2F;&#x2F;        FileInputStream fileInputStream1 &#x3D; new FileInputStream(&quot;F:\\\\newBlog\\\\source\\\\img\\\\inspiration.jfif&quot;);\n\n        ServletOutputStream outputStream &#x3D; resp.getOutputStream();\n\n        IOUtils.copy(fileInputStream, outputStream);\n\n\n\n是否加虚拟目录问题\n\nidea修改模板的小工具以后我们每次编写post都要调用doGet, 所以我们要修改模板, 在创建servlet类的时候自动创建;\n\n首先我们有这个模板, 我们只需要更改一下\n\n找到地址之后, 我们改两个地方:\n\n\n","slug":"TomcatServlet/Tomcat-Servlet-study-day02","date":"2022-11-18T08:26:06.000Z","categories_index":"Study","tags_index":"Tomcat,Servlet","author_index":"Someone Serious"},{"id":"27c7493502c2dd3c944effcfc2ce9fdc","title":"Tomcat&Servlet study day01","content":"\n\n\n\n\n\n提示\n一般的java项目是用jar包打包的, 而webapp使用war包打包的, 更改方式在maven的配置里面\n  &lt;groupId&gt;com.MyCompany&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;Mybatis&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n  &lt;packaging&gt;jar&lt;&#x2F;packaging&gt;\n&lt;!--  下面是war包--&gt;\n&lt;!--  &lt;packaging&gt;war&lt;&#x2F;packaging&gt;--&gt;\n\n\n\n安装Tomcat1. 通过maven的方法安装Tomcat在maven的helloworld里面有所展示, 这里就不多赘述了. \n2. 通过下载的方式导入Tomcat因为maven最多支持到Tomcat7, 想要更高的版本我们只能去官网下载. \n\n\n\n\n\n\n提示\n官网下载的是绿色版, 既解压可用, 不需要安装与卸载\n\n\n首先要配置Tomcat. 就在根目录下面的conf里面的server.xml\n&lt;!-- 下面的port更改端口 --&gt;   \n&lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;\n               connectionTimeout&#x3D;&quot;20000&quot;\n               redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;\n\n\n\n\n\n\n\n提示\n80端口是默认端口, 也就是说, 如果只输入localhost, 后面不输入端口, 则默认是80端口, 这是一个特殊的端口, 我们也可以设置\n:::\t\n:::warning\ntomcat的编码默认是UTF-8, 这时会产生乱码的, 我们要把他改成GBK\n在/conf/logging.properties下,\njava.util.logging.ConsoleHandler.encoding &#x3D; GBK\n\n\n\n\n3.通过编辑配置的方法部署Tomcat\n注意, 其中要设置默认浏览器, 本地tomcat的地址, 端口号. url地址. \n\n在部署里, 把包添加进去, \n\n\n\n\n\n\n提示\n注意下面的程序上下文, 更改可以更改页面默认的地址\n\n\n\nServlettomcat作为服务器, 是帮助用户处理http协议, 快捷简便的搭建服务器, 而servlet是用于处理动态事务, 它只是一个规范, 一个接口, 一共有五个方法. \n\n\n\n\n\n\n\n注意\n下面的包是错误的\n    &lt;dependency&gt;\n      &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;2.5&lt;&#x2F;version&gt;\n\n&lt;!--      注意, 下面一定要注意使用provided, 因为这样导出的包就没有servlet包了, 不然会与tomcat重合, 引发错误--&gt;\n      &lt;scope&gt;provided&lt;&#x2F;scope&gt;\n    &lt;&#x2F;dependency&gt;\n\n下面的是正确的\n&lt;dependency&gt;\n  &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;3.1.0&lt;&#x2F;version&gt;\n  &lt;scope&gt;provided&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n\n\n下面是实现接口&#x2F;&#x2F;下面是用来表明我的Servlet的目录地址\n@WebServlet(&quot;&#x2F;MyServlet&quot;)\npublic class MyServlet implements Servlet &#123;\n    \n    private ServletConfig servletConfig;\n\n    &#x2F;&#x2F;初始化, 可以设置在服务器启动时就初始化, 也可以设置在第一次打开时初始化\n    public void init(ServletConfig servletConfig) throws ServletException &#123;\n        this.servletConfig &#x3D; servletConfig;\n    &#125;\n\n    &#x2F;&#x2F;每次打开网页时触发这个方法\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;\n\n    &#125;\n\n    &#x2F;&#x2F;结束servlet时触发这个方法, 注意! 不是关闭页面, 而是结束servlet\n    public void destroy() &#123;\n\n    &#125;\n    \n    &#x2F;&#x2F;这个方法用于返回该servlet的配置, 在初始化时会传输一个配置, 传回去就好了\n    public ServletConfig getServletConfig() &#123;\n        return servletConfig;\n    &#125;\n\n\n    &#x2F;&#x2F;这个方法用于返回servlet的信息, 我们暂时返回null就可以了\n    public String getServletInfo() &#123;\n        return null;\n    &#125;\n\n\n&#125;\n\nHttpServlethttpServlet是对Servlet接口的一种实现, 我们就没有必要再用那个破接口了, 而可以直接使用现成的类, 并重写它已达到我们的目的. \n主要重写以下两个方法\n@WebServlet(&quot;&#x2F;MyHttpServlet&quot;)\npublic class MyHttpServlet extends HttpServlet &#123;\n\t\n    &#x2F;&#x2F;对get请求处理(直接登录页面算get请求)\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        super.doGet(req, resp);\n    &#125;\n\t\n    &#x2F;&#x2F;对post请求处理\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        super.doPost(req, resp);\n    &#125;\n&#125;\n\n那么我们还不得不再说一下get与post的不同\nGet and PostGet同于传少量数据(最大不能超过4kb), 并且存放于请求头, 没有请求体\npost用于存放大量数据, 存放于请求体, 更加安全, 我们一般选用post请求方式.\n\n一个servlet可以有多个地址通过输入配置@WebServlet(urlPatterns &#x3D; &#123;&quot;&#x2F;MyHttpServlet1&quot;, &quot;&#x2F;MyHttpServlet2&quot;&#125;)\n\n通过urlPattern配置\n\n\n\n\n\n\n提示\n如果同时满足多个匹配, 则图中的顺序同时也是优先级\n注意同种的第三种匹配, 它前面不能有/\n注意第四种方法, 不要用”&#x2F;“的方法, 因为它会覆盖掉tomcat中默认的帮助访问静态资源的servlet\n\n\n","slug":"TomcatServlet/Tomcat-Servlet-study-day01","date":"2022-11-17T13:36:48.000Z","categories_index":"Study","tags_index":"Tomcat,Servlet","author_index":"Someone Serious"},{"id":"5e5d631a7897b1bae550b31b22f44657","title":"javaScript 表单验证","content":"说明实现用javaScript实现对表单数据的合法性认证, 表单包括:  用户名, 密码, 邮箱\n\n1. 创建html文件&lt;form id &#x3D; &quot;userPost&quot; method&#x3D;&quot;post&quot;&gt;\n    &lt;label for&#x3D;&quot;username&quot;&gt;用户名: &lt;&#x2F;label&gt;\n    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;input_username&quot; name&#x3D;&quot;username&quot;&gt; &lt;br&gt;\n    &lt;div id &#x3D; &quot;div_username&quot; class &#x3D; &quot;errorMessage&quot;&gt;用户名输入失败&lt;&#x2F;div&gt;\n\n    &lt;label for&#x3D;&quot;password&quot;&gt;密码: &lt;&#x2F;label&gt;\n    &lt;input type&#x3D;&quot;div_text&quot; id&#x3D;&quot;input_password&quot; name&#x3D;&quot;password&quot;&gt; &lt;br&gt;\n    &lt;div id &#x3D; &quot;password&quot; class &#x3D; &quot;errorMessage&quot;&gt;密码输入失败&lt;&#x2F;div&gt;\n\n    &lt;label for&#x3D;&quot;Email&quot;&gt;邮箱: &lt;&#x2F;label&gt;\n    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;input_Email&quot; name&#x3D;&quot;Email&quot;&gt; &lt;br&gt;\n    &lt;div id &#x3D; &quot;div_Email&quot; class &#x3D; &quot;errorMessage&quot;&gt;邮箱输入失败&lt;&#x2F;div&gt;\n\n    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;submit&quot;&gt;\n\n&lt;&#x2F;form&gt;\n\n和简单的css内容\n&lt;style&gt;\n\t\n    &#x2F;* 注意这里的display *&#x2F;\n    .errorMessage&#123;\n        color: red;\n        display: none;\n    &#125;\n\n\n&lt;&#x2F;style&gt;\n\n\n2. 创建判断的方法与规则我们通过正则表达式进行判断\n&#x2F;&#x2F;获取对应的元素\nconst usernameInput &#x3D; document.querySelector(&quot;#input_username&quot;)\nconst passwordInput &#x3D; document.querySelector(&quot;#input_password&quot;)\nconst EmailInput &#x3D; document.querySelector(&quot;#input_Email&quot;)\n\nfunction is_username_correct()&#123;\n\n    &#x2F;&#x2F;编写正则表达式, 是字母与数字的组合, 最少六个, 最多12个\n    const patt &#x3D; &#x2F;^[\\d\\w]&#123;6,12&#125;$&#x2F;\n    \n\n    &#x2F;&#x2F;注意后面省略空格\n    const username &#x3D; usernameInput.value.trim()\n    flag &#x3D; patt.test(username)\n    \n    &#x2F;&#x2F;创建提示div对象\n    const div_username &#x3D; document.querySelector(&quot;#div_username&quot;)\n    if (flag)&#123;\n        \n        div_username.style.display &#x3D; &#39;none&#39;\n    &#125;else&#123;\n        div_username.style.display &#x3D; &#39;block&#39;\n    &#125;\n    return flag\n&#125;\n\nfunction is_password_correct()&#123;\n\n&#x2F;&#x2F;编写正则表达式, 必须有一个大写字母, 一个小写字母, 一个数字, 其他随意\nconst patt &#x3D; &#x2F;^(?&#x3D;.*[a-z])(?&#x3D;.*[A-Z])(?&#x3D;.*\\d)[^]&#123;8,16&#125;$&#x2F;\n\n\n&#x2F;&#x2F;注意后面省略空格\nconst password &#x3D; passwordInput.value.trim()\nflag &#x3D; patt.test(password)\n\n&#x2F;&#x2F;创建提示div对象\nconst div &#x3D; document.querySelector(&quot;#div_password&quot;)\nif (flag)&#123;\n    \n    div.style.display &#x3D; &#39;none&#39;\n&#125;else&#123;\n    div.style.display &#x3D; &#39;block&#39;\n&#125;\nreturn flag\n&#125;\n\nfunction is_Email_correct()&#123;\n\n&#x2F;&#x2F;编写正则表达式, 匹配邮箱\nconst patt &#x3D; &#x2F;^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$&#x2F;\n\n\n&#x2F;&#x2F;注意后面省略空格\nconst Email &#x3D; EmailInput.value.trim()\nflag &#x3D; patt.test(Email)\n\n&#x2F;&#x2F;创建提示div对象\nconst div &#x3D; document.querySelector(&quot;#div_Email&quot;)\nif (flag)&#123;\n    \n    div.style.display &#x3D; &#39;none&#39;\n&#125;else&#123;\n    div.style.display &#x3D; &#39;block&#39;\n&#125;\nreturn flag\n&#125;\n\n\n3. 创建事件监听&#x2F;&#x2F; onblur表示: 在表单失真的时候启动    \nusernameInput.onblur &#x3D; is_username_correct \npasswordInput.onblur &#x3D; is_password_correct\nEmailInput.onblur &#x3D; is_Email_correct\n\n\n4. 判断是否允许提交\n\n\n\n\n\n提示\n表单(form)有一个onsubmit属性, 为false时不能提交\n\n\n&#x2F;&#x2F;注意, 这里是要form表, 而不是submit按钮\nconst submit &#x3D; document.querySelector(&quot;#userPost&quot;)\n\n\nfunction x()&#123;\n    &#x2F;&#x2F; 这里一定要注意, 是调用方法而不是返回方法, 就是注意后面的括号. \n    return (is_Email_correct() &amp;&amp; is_password_correct() &amp;&amp; is_username_correct())\n&#125;\n\n&#x2F;&#x2F; from的onsubmit属性要求传入一个方法, 如果方法返回值为true则可以提交, 否则不能提交\nsubmit.onsubmit &#x3D; x\n\n\ntheEND说实话, vscode没有idea好用, 感觉有点捞. \n","slug":"HtmlCssJs/javaScript-表单验证","date":"2022-11-17T06:36:01.000Z","categories_index":"Result","tags_index":"javaScript","author_index":"Someone Serious"},{"id":"c051c340bfcf71b6b3f4eb3eda1e06c5","title":"javaScript Skill 01","content":"这是我的第一篇关于skill的文章, 将来这个类别用于存放技巧性的内容. \n关于检验数字将String转换为数字有两种方法:\nlet x1 &#x3D; +&quot;123&quot;; &#x2F;&#x2F; 第一种, 前面加一个+号\n\nx1 &#x3D; parseInt(x1); &#x2F;&#x2F; 第二种, 用转化的方法\n\n其中第一种方法有潜在的问题, 它会把空字符串转化为0. \n\nlet x1 &#x3D; +&quot;&quot;;\nconsole.log(x1 &#x3D;&#x3D;&#x3D; 0);\n\n所以我们用下面第二种方法, 它则会转化成NaN类型. \n\n判断空字符串if (str)&#123;\n    &#x2F;&#x2F;非空转并且非null化为true\n&#125;else&#123;\n&#125;\n\n\n移除字符串前后空格let str &#x3D; &quot;   asdf   &quot;\n\nconsole.log(str.trim())\nconsole.log(str)\n\n\n表单验证传送门\n","slug":"HtmlCssJs/javaScript-Skill-01","date":"2022-11-17T04:50:00.000Z","categories_index":"Skill","tags_index":"javaScript","author_index":"Someone Serious"},{"id":"348916b1a49009463576057a41ee1394","title":"Mybatis Study day02","content":"为什么只有day2没有day1呢, 因为day1直接当做指导性博客了.\n如何使用resultMap对数据封装在此之前, 要引入mybatisx的插件\n\n1. 问题描述public class User &#123;\n\n    private Integer id;\n\n    &#x2F;&#x2F; 现在出现了问题, 数据库中的对应命名是username, 但是我们用驼峰命名会出现不一致\n    private String userName;\n    private String password;\n    private String gender;\n    private String addr;\n    &#x2F;&#x2F;后面省略\n\n2. 问题解决    &lt;resultMap id&#x3D;&quot;UserResultMap&quot; type&#x3D;&quot;com.MyCompany.pojo.User&quot;&gt;\n&lt;!--        id用来完成主键字段的映射--&gt;\n&lt;!--        &lt;id    --&gt;\n        &lt;!---用result完成一般映射--&gt;\n        &lt;result column&#x3D;&quot;username&quot; property&#x3D;&quot;userName&quot;&#x2F;&gt;\n    &lt;&#x2F;resultMap&gt;\n    \n&lt;!--    注意后面的resultType改成Map--&gt;\n    &lt;select id&#x3D;&quot;selectAll&quot; resultMap&#x3D;&quot;UserResultMap&quot;&gt;\n        select *\n        from tb_user;\n    &lt;&#x2F;select&gt;\n\nmyBatis条件查询\n通过姓名和性别查找对应的用户信息:\n1. 编写查找语句&lt;select id&#x3D;&quot;selectByNameAndGender&quot; resultMap&#x3D;&quot;UserResultMap&quot;&gt;\n\n    select * from tb_user\n             where username like #&#123;userName&#125; and\n                   gender like #&#123;gender&#125;;\n                   \n&lt;&#x2F;select&gt;\n\n传入参数三种方法public interface UserMapper &#123;\n\n&#x2F;&#x2F;    &#x2F;&#x2F;这里的方法返回类型需要和mapper中一致, 参数也要一致\n&#x2F;&#x2F;    &#x2F;&#x2F; 这里的方法名就是mapper中的id.\n&#x2F;&#x2F;    List&lt;User&gt; selectAll();\n\n    &#x2F;&#x2F; 通过标签传入参数, 标签中对应是#&#123;&#125;中的内容\n    List&lt;User&gt; selectByNameAndGender(@Param(&quot;userName&quot;)String userName, @Param(&quot;gender&quot;)String gender);\n\n    &#x2F;&#x2F; 通过类传递信息, 要类中的名字与#&#123;&#125;中相同\n    List&lt;User&gt; selectByNameAndGender(User user);\n    \n    &#x2F;&#x2F;通过字典传递参数, key &#x3D; #&#123;&#125;中的元素, value &#x3D; 对应的数据.\n    List&lt;User&gt; selectByNameAndGender(Map&lt;String,String&gt; map);\n\n\n\n&#125;\n\nmain方法:&#x2F;&#x2F; 注意, 这里要模糊查询, 因为要满足业务逻辑\nString name &#x3D; &quot;%王五%&quot;;\nString gender &#x3D; &quot;%男%&quot;;\n\nMap&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();\nmap.put(&quot;userName&quot;, name);\nmap.put(&quot;gender&quot;, gender);\n\nUser user &#x3D; new User();\nuser.setGender(gender);\nuser.setUserName(name);\n\n&#x2F;&#x2F;三种方法\nList&lt;User&gt; users1 &#x3D; mapper.selectByNameAndGender(name, gender);\nList&lt;User&gt; users2 &#x3D; mapper.selectByNameAndGender(map);\nList&lt;User&gt; users3 &#x3D; mapper.selectByNameAndGender(user);\n\n\nSystem.out.println(users1);\nSystem.out.println(users2);\nSystem.out.println(users3);\n\nsqlSession.close();\n\n动态sqlmyBatis提供了动态sql的能力, 是myBatis的强大功能之一. \n下面是它的标签: \n\nif\nchoose (when, otherwise)\ntrim (where, set)\nforeach\n\nif比如我们希望用户输入null值时, 我们就忽略那一项查询条件:\n&lt;select id&#x3D;&quot;selectByNameAndGender&quot; resultMap&#x3D;&quot;UserResultMap&quot;&gt;\n\n    select * from tb_user\n    &lt;!--注意这里用where的标签, 不然会有sql语言格式问题--&gt;\n    &lt;where&gt;\n        \n        &lt;!--test里面写条件--&gt;\n    &lt;if test&#x3D;&quot;userName !&#x3D; null and userName !&#x3D; &#39;&#39;&quot;&gt;\n        and username like #&#123;userName&#125;\n    &lt;&#x2F;if&gt;\n\n    &lt;if test&#x3D;&quot;gender !&#x3D; null and gender !&#x3D; &#39;&#39;&quot;&gt;\n        and gender like #&#123;gender&#125;\n    &lt;&#x2F;if&gt;\n    &lt;&#x2F;where&gt;\n    ;\n\n&lt;&#x2F;select&gt;\n\n\n\n\n\n\n\n提示\n关于系统不给数据库相关提示的问题, 在sql方言的设置中, 设置\n\n\n\n添加数据\n注意提交事务\n主键返回添加了的数据, 我们像要返回它们的主键, (因为主键不是用户输入的, 而是系统auto_increment的), 所以我们要求返回主键\n做法:\n首先设置默认提交, (或者也可以手动提交)\nSqlSession sqlSession &#x3D; sqlSessionFactory.openSession(true);\n\n设置xml, 注意上面的参数\n&lt;insert id&#x3D;&quot;insertAll&quot; useGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;id&quot;&gt;\n    insert into tb_user (username, password, gender, addr)\n    values (#&#123;userName&#125;, #&#123;password&#125;,#&#123;gender&#125;,#&#123;addr&#125;);\n&lt;&#x2F;insert&gt;\n\n通过下面的代码实现回调\nUser user &#x3D; new User();\nuser.setUserName(&quot;老刘&quot;);\nuser.setGender(&quot;女&quot;);\nuser.setAddr(&quot;地球&quot;);\nuser.setPassword(&quot;123456&quot;);\n\nmapper.insertAll(user);\nSystem.out.println(user.getId());\n\n修改数据\n批量删除1.设置接口注意标签\nvoid deleteByIds(@Param(&quot;ids&quot;) List&lt;Integer&gt; ids);\n\n2. 设置mapper&lt;delete id&#x3D;&quot;deleteByIds&quot;&gt;\n    delete from tb_user where id\n    in\n        &lt;foreach collection&#x3D;&quot;ids&quot; item&#x3D;&quot;id&quot; separator&#x3D;&quot;,&quot; open&#x3D;&quot;(&quot; close&#x3D;&quot;);&quot;&gt;\n            #&#123;id&#125;\n        &lt;&#x2F;foreach&gt;\n\n&lt;&#x2F;delete&gt;\n\n注意上面的collection要与标签中一致\n3.测试List&lt;Integer&gt; ids &#x3D; new ArrayList&lt;Integer&gt;();\nids.add(7);\nids.add(8);\n\nmapper.deleteByIds(ids);\n\n\n\n深度理解Mybatis的参数注入Mybatis是通过字典的方式传递参数, 你输入一个参数, 参数前面跟注解@param(&#39;key&#39;), 注解里面的内容就是这个字典的key, 而value就是你传入的数据, 所以在sql查询语句中, 你就是通过key得到那个数据. \n所以,如果你传入的是一个类, 你可以通过.的方法, 得到里面的数据:\n&lt;delete id&#x3D;&quot;deleteByIds&quot;&gt;\n    delete from tb_user where tb_user.username\n    in\n        &lt;foreach collection&#x3D;&quot;map&quot; item&#x3D;&quot;user&quot; separator&#x3D;&quot;,&quot; open&#x3D;&quot;(&quot; close&#x3D;&quot;);&quot;&gt;\n            #&#123;user.userName&#125;\n        &lt;&#x2F;foreach&gt;\n\n&lt;&#x2F;delete&gt;\n\n\n\nTheEND今天就学习到这了, 摆烂了一上午加一下午, 晚上和老师聊了聊当代青年的精神问题, 老师认为, 虽然现在年轻人吃穿不愁, 但是可能比老一辈日子过的还要苦, 他们很多老师都已经受不了现在的学生了. \n注解开发再学半小时\n\n明天开Http的坑\n","slug":"MyBatis/Mybatis-Study-day02","date":"2022-11-16T10:13:42.000Z","categories_index":"Study","tags_index":"MyBatis","author_index":"Someone Serious"},{"id":"39921d9204478d3700dd9ed949b5c503","title":"MyBatis Mapper HelloWorld","content":"JavaEE 三层架构表现层: 可视化用户接触层\n业务层: 实现业务逻辑层\n持久层: 数据库交互层 Mybatis就是作用在这\n它是为了简化JDBC而产生的的一套框架\n接下来的实验, 创建一个数据库, 一张表, 查询表里的所有数据: \n\n\n入门_MyBatis中文网\n1. 创建表\nCreate DATABASE Mybatis;\nUse Mybatis;\n\ndrop table if EXISTS tb_user;\n\ncreate table tb_user(\n\tid int PRIMARY KEY auto_increment,\n\tusername VARCHAR(20),\n\tpassword VARCHAR(20),\n\tgender char(1),\n\taddr VARCHAR(30)\n\t);\n\n\ninsert into tb_user VALUES (1, &#39;zhangsan&#39;,&#39;123&#39;, &#39;男&#39;, &#39;北京&#39;), (2, &#39;李四&#39;, &#39;234&#39;, &#39;女&#39;, &#39;天津&#39;), (3, &#39;王五&#39;, &#39;11&#39;, &#39;男&#39;, &#39;西安&#39;);\n\n2. 创建项目, Maven依赖&lt;dependency&gt;\n  &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;3.5.11&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n  &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;8.0.29&lt;&#x2F;version&gt;\n\n&lt;&#x2F;dependency&gt;\n\n3. 创建Mybatis xml配置文件具体代码看官网, 只要注意更改里面数据库的信息就可以了, 还有注意xml配置文件的导入\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;\n\n&lt;configuration&gt;\n    &lt;environments default&#x3D;&quot;development&quot;&gt;\n        &lt;environment id&#x3D;&quot;development&quot;&gt;\n            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;\n            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;\n                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;mybatis&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;\n                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;Sxs12367&quot;&#x2F;&gt;\n            &lt;&#x2F;dataSource&gt;\n        &lt;&#x2F;environment&gt;\n    &lt;&#x2F;environments&gt;\n    &lt;mappers&gt;\n\n&lt;!--        这是查询xml的导入--&gt;\n        &lt;mapper resource&#x3D;&quot;UserMapper.xml&quot;&#x2F;&gt;\n    &lt;&#x2F;mappers&gt;\n&lt;&#x2F;configuration&gt;\n\n4. 创建存储数据的类package com.MyCompany.pojo;\n\npublic class User &#123;\n\n    private Integer id;\n    private String username;\n    private String password;\n    private String gender;\n    private String addr;\n    \n    &#x2F;&#x2F;后面的getset方法, tostring方法全部省略\n\n5. 创建映射器(Mapper)这个映射器就是上面配置xml中添加的mapper\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;\n\n&lt;!--名称空间, 加上下面的id, 一起确定唯一查询语句--&gt;\n&lt;mapper namespace&#x3D;&quot;test&quot;&gt;\n    &lt;!--后面的resultType用于表示查询单挑数据存放的类, 就是我们创建的User类---&gt;\n    &lt;select id&#x3D;&quot;selectAll&quot; resultType&#x3D;&quot;com.MyCompany.pojo.User&quot;&gt;\n        select * from tb_user;\n    &lt;&#x2F;select&gt;\n&lt;&#x2F;mapper&gt;\n\n\n\n6. 创建main方法, 启动查询代码在官网都有, \npublic class Mybatis_demo\n&#123;\n    public static void main( String[] args ) throws IOException &#123;\n\n        &#x2F;&#x2F;创建 SqlSessionFactory 工厂对象, 为了创建sqlSession对象\n        &#x2F;&#x2F; String传入myBatis配置文件\n        String resource &#x3D; &quot;mybatis-config.xml&quot;;\n        InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);\n        SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);\n\n        &#x2F;&#x2F;创建SqlSession\n        SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();\n\n        &#x2F;&#x2F;执行sql, 因为查询结果是一个List, 所以用List的方法, 参数就是名称空间.id\n        List&lt;User&gt; users &#x3D; sqlSession.selectList(&quot;test.selectAll&quot;);\n\n        System.out.println(users);\n\t\t\n        &#x2F;&#x2F;注意关掉查询\n        sqlSession.close();\n\n\n\n    &#125;\n&#125;\n\n最后的结构\nMapper代理\n调用xml中的查询方法没有代码补全, 比较麻烦, 所以我们会用mapper代理开发sql查询语句\n1. 创建Mapper接口Mapper是一个接口, 但是它必须和sql映射文件同名, 并且放在同一目录下\n\n\n\n\n\n\n提示\n创建包时,  报名之间的.可以使一个包变成一层层的文件夹, 但是创建普通文件夹的时候, 我们就要用如下的方法:\n“com&#x2F;MyCompany&#x2F;Mapper”\n\n\npublic interface UserMapper &#123;\n\n    &#x2F;&#x2F;这里的方法返回类型需要和mapper中一致, 参数也要一致\n    &#x2F;&#x2F; 这里的方法名就是mapper中的id.\n    List&lt;User&gt; selectAll();\n\n&#125;\n\n这样也是在同一目录下:\n\n2. 更新myBatis配置文件Mapper地址    &lt;mappers&gt;\n\n&lt;!--        这是查询xml的导入--&gt;\n&lt;!--        &lt;mapper resource&#x3D;&quot;com&#x2F;MyCompany&#x2F;Mapper&#x2F;UserMapper.xml&quot;&#x2F;&gt;--&gt;\n&lt;!--        上面是单条导入, 一般用下面的方法, 直接整包导入--&gt;\n        &lt;package name&#x3D;&quot;com.MyCompany.Mapper&quot;&#x2F;&gt;\n    &lt;&#x2F;mappers&gt;\n\n3. 更新Mapper配置文件中的namespace&lt;!--名称空间--&gt;\n&lt;mapper namespace&#x3D;&quot;com.MyCompany.Mapper.UserMapper&quot;&gt;\n    &lt;select id&#x3D;&quot;selectAll&quot; resultType&#x3D;&quot;com.MyCompany.pojo.User&quot;&gt;\n        select *\n        from tb_user;\n    &lt;&#x2F;select&gt;\n&lt;&#x2F;mapper&gt;\n\n注意, 要更新namespace为包目录下的对应接口\n4. 在main方法中更改&#x2F;&#x2F;创建SqlSession\n\nSqlSession sqlSession &#x3D; sqlSessionFactory.openSession();\n\n&#x2F;&#x2F;调用sqlSession方法得到相应的mapper类\nUserMapper mapper &#x3D; sqlSession.getMapper(UserMapper.class);\nList&lt;User&gt; users &#x3D; mapper.selectAll();\n\n\nSystem.out.println(users);\n\n以后统一用mapper代理了. \n","slug":"MyBatis/Mybatis_res_HelloWorld","date":"2022-11-15T12:31:54.000Z","categories_index":"Result","tags_index":"MyBatis","author_index":"Someone Serious"},{"id":"f8bddff16c64cf44d055f0f968e054f2","title":"C study day01","content":"我觉得C语言足够难, 够我开一个档来学习, 但是我今天学C的目的是为了完成我的实验, 所以实验结束之后我估计就会搁置C一段时间. \n学习传送门\n留着学吧,\nSwitch的技巧下面是一般情况, \nint main() &#123;\nint x;\n\n&#x2F;&#x2F;输入x的值\nscanf(&quot;%d&quot;, &amp;x);\n\n&#x2F;&#x2F;作条件判断\nswitch (x) &#123;\n    case 1:\n        printf(&quot;星期一&quot;);\n        break;\n    case 2:\n        printf(&quot;星期二&quot;);\n        break;\n    case 3:\n        printf(&quot;星期三&quot;);\n        break;\n    case 4:\n        printf(&quot;星期四&quot;);\n        break;\n    case 5:\n        printf(&quot;星期五&quot;);\n        break;\n    case 6:\n        printf(&quot;星期六&quot;);\n        break;\n    case 7:\n        printf(&quot;星期天&quot;);\n        break;\n&#125;\n&#125;\n\n\n\n\n\n\n\n提示\nswitch里面case只能是常量, 至少也得是常变量\nint x;\nint const y &#x3D; 1;\n\n&#x2F;&#x2F;输入x的值\nscanf(&quot;%d&quot;, &amp;x);\n\n&#x2F;&#x2F;作条件判断\nswitch (x) &#123;\n    case y:\n        printf(&quot;星期一&quot;);\n        break;\n&#125;\n\n\n\nint main() &#123;\nint x;\n\n&#x2F;&#x2F;输入x的值\nscanf(&quot;%d&quot;, &amp;x);\n\n&#x2F;&#x2F;作条件判断\nswitch (x) &#123;\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n        printf(&quot;workDay&quot;);\n        break;\n    case 6:\n    case 7:\n        printf(&quot;sunDay&quot;);\n        break;\n    default:\n        printf(&quot;输入错误&quot;);\n        break;\n&#125;\n&#125;\n\n\n可以通过上面的方法, 简化switch的语法. \ngetchar()与持续输入与正确输入持续输入\nint main() &#123;\n\t\n    &#x2F;&#x2F;getchar返回的是int值, 我要用int接受\n    int x;\n\n    &#x2F;&#x2F; 这里的判断还是判断x与EOF是否相等， 而EOF是 End of file 数值是-1, 键盘输入是ctrl + z\n    while ((x &#x3D; getchar()) !&#x3D; EOF)&#123;\n\n        &#x2F;&#x2F; 下面两种输入方式是相同的\n        putchar(x);\n        printf(&quot;%c&quot;, x);\n\n    &#125;\n\n\n&#125;\n\n\n注意, 每次输入可输入多值, 但是还是按照一个字符一个字符处理.\nWindows的EOF输入通过 ctrl+z, 而linux则通过ctrl + d\n正确输入c语言中有一个输入缓冲区的概念, 输入的值会存放在输入缓冲区, 我们输入字符串的时候, 我们输入的空格, 或者回车不会被scanf(&quot;%s&quot;, str)读取, 而多余的部分就会存放在输入缓冲区中. 下一个读取函数就会直接读取缓冲区中的内容, 所以我们要用getchar()来使得缓冲区清空. \nint main() &#123;\n\n    int x;\n    char str1[20] ;\n    char str2[20];\n\n    scanf(&quot;%s&quot;, str1);\n    \n    &#x2F;&#x2F; 注意这里用字符而不是字符串， 用&#39;&#39;而不用&quot;&quot;\n    while ((x &#x3D; getchar()) !&#x3D; &#39;\\n&#39;)&#123;\n        \n    &#125;\n\n    scanf(&quot;%s&quot;, str2);\n    printf(&quot;%s,%s\\n&quot;, str1, str2);\n    &#125;\n\n\n","slug":"C/C-study-day01","date":"2022-11-14T14:44:27.000Z","categories_index":"Study","tags_index":"C","author_index":"Someone Serious"},{"id":"fec74b413dc2868cc0a4ce6e062f6692","title":"MySql Study day01","content":"数据库设计一对一一般用于表拆分, 一张用于常用查询, 一张用于非常用查询, 通过设置唯一外键实现\n一对多设置外键, 多的一放设置外键, 指向一的一放的主键. \n多对多设置另一张表, 包含两个外键, 包含两个表的两个主键. \n\n多表查询select 字段列表 from 表 where 字段名 &#x3D; (子查询)\n\n单行单列直接用大于小于等于\n多列单行用in()查询\n多行多列作为from后面的表进行查询\nselect 字段列表 from (子查询)t1 where 字段名 &#x3D; ...\n\n子查询后面跟的t1用来称呼前面的子查询.\n内连接select\n\ttable1.id\n\ttable1.name\n\ttable2.data\n\ttable3.data\nfrom\n\ttable1\nInner join table2 on table2.id &#x3D; table1.id\nInner join table3 on table3.id &#x3D; table1.id\n\n\n\nJDBC是java语言来操作sql语言的一套API接口, java代码没有办法用同一套代码操控不同的数据库, 所以为了解决这个问题, sun公司创造了JDBC规范, 就是一个接口, 而不同的数据库则根据JDBC制作实现类, 我们以后就可以通过接口用同一套代码了, 当然要导入相应数据库的实现类, 就是相应数据库的jar包, 也叫驱动.\n\n导入JDBC\n导入相应的驱动\n&lt;dependency&gt;\n  &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;8.0.28&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n代码展示\npackage com.myCompany.JDBC;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.Statement;\n\npublic class JDBCDemo &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n\n        &#x2F;&#x2F; 1. 导入相关驱动\n        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n\n        &#x2F;&#x2F;2. 创建相关连接\n        String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jdbc_demo&quot;;\n        String userName &#x3D; &quot;root&quot;;\n        String password &#x3D; &quot;Sxs12367&quot;;\n        Connection connection &#x3D; DriverManager.getConnection(url, userName, password);\n\n        &#x2F;&#x2F;3. 编写相关查询语句\n        String sql &#x3D; &quot;create TABLE table_demo(\\n&quot; +\n                &quot;    id int primary key ,\\n&quot; +\n                &quot;    name varchar(10) not null ,\\n&quot; +\n                &quot;    money int\\n&quot; +\n                &quot;);&quot;;\n\n        &#x2F;&#x2F;4. 由相关连接创建一个相关查询(新建查询)\n        Statement statement &#x3D; connection.createStatement();\n\n        &#x2F;&#x2F;5. 查询, 返回值count &#x3D; 影响行数\n        int count &#x3D; statement.executeUpdate(sql);\n        \n        &#x2F;&#x2F;6. 释放内存\n        connection.close();\n        statement.close();\n    &#125;\n&#125;\n\n\n\n\n\n\n\n提示\n现在的高版本启动已经不需要第一行导入驱动的代码了, 现在自动导入. \nurl的格式是 ** jdbc:mysql:&#x2F;&#x2F;(ip地址+端口号)&#x2F;(数据库名)\n如果是本机的3306号端口的话, 可以省略.\n\n\n\n通过connection来操作事务\npublic class JDBCDemo &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n\n&#x2F;&#x2F;        &#x2F;&#x2F; 1. 导入相关驱动\n&#x2F;&#x2F;        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n\n        &#x2F;&#x2F;2. 创建相关连接\n        String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jdbc_demo&quot;;\n        String userName &#x3D; &quot;root&quot;;\n        String password &#x3D; &quot;Sxs12367&quot;;\n        Connection connection &#x3D; DriverManager.getConnection(url, userName, password);\n\n        &#x2F;&#x2F;3. 编写相关查询语句\n        String sql1 &#x3D; &quot;create TABLE table_demo(\\n&quot; +\n                &quot;    id int primary key ,\\n&quot; +\n                &quot;    name varchar(10) not null ,\\n&quot; +\n                &quot;    money int\\n&quot; +\n                &quot;);&quot;;\n        String sql2 &#x3D;&quot;drop TABLE  table_demo;&quot;;\n\n        &#x2F;&#x2F;4. 由相关连接创建一个相关查询(新建查询)\n        Statement statement &#x3D; connection.createStatement();\n\n        try &#123;\n            &#x2F;&#x2F;开启事务\n            connection.setAutoCommit(false);\n\n            statement.executeUpdate(sql1);\n            statement.executeUpdate(sql2);\n            &#x2F;&#x2F;提交事务\n            connection.commit();\n\n        &#125;catch (Exception e)&#123;\n            &#x2F;&#x2F;回滚事务\n            connection.rollback();\n            System.out.println(&quot;回滚事务&quot;);\n        &#125;\n\n\n        &#x2F;&#x2F;6. 释放内存\n        connection.close();\n        statement.close();\n    &#125;\n&#125;\n\nStatement返回值处理\n如果是处理DML语言, 就是对数据进行增删改操作时, 如果成功返回值是大于0的, 可以通过此判断, 但是如果是DDL, 就是对数据库或者表的元素的增删改, 他的值即使成功也有可能为0, 判断方法是不报错就是成功. \n\nStatement查询语句处理\npublic class JDBCDemo &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n\n&#x2F;&#x2F;        &#x2F;&#x2F; 1. 导入相关驱动\n&#x2F;&#x2F;        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n\n        &#x2F;&#x2F;2. 创建相关连接\n        String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jdbc_demo&quot;;\n        String userName &#x3D; &quot;root&quot;;\n        String password &#x3D; &quot;Sxs12367&quot;;\n        Connection connection &#x3D; DriverManager.getConnection(url, userName, password);\n\n        Statement statement &#x3D; connection.createStatement();\n\n        String sql &#x3D; &quot;select * from table_demo;&quot;;\n        &#x2F;&#x2F;注意, DQL语句的方法和其他方法不一样, 会返回一个ResultSet类型的查询结果\n        ResultSet resultSet &#x3D; statement.executeQuery(sql);\n\n        &#x2F;&#x2F;.next()返回下一行是否不为空, 并将指针移动到下一行, 一开始在第一行数据的上一行\n        while (resultSet.next())&#123;\n\n            &#x2F;&#x2F; 用getxxx的方法获取数据, 参数可以填列数, 也可以填列名, 注意! 列数从1开始\n            System.out.println(resultSet.getInt(1));\n            System.out.println(resultSet.getString(2));\n            System.out.println(resultSet.getInt(&quot;money&quot;));\n            System.out.println(&quot;-----------------&quot;);\n        &#125;\n\n\n        &#x2F;&#x2F;6. 释放内存, 注意要释放掉resultSet的内存\n        resultSet.close();\n\n\n        connection.close();\n        statement.close();\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n注意\n实际业务中我们并不是直接处理数据, 而是要把它封装在一个实体类, 并装入一个列表中使用的, 代码展示入下\n\n\npackage com.myCompany.pojo;\n\npublic class User &#123;\n\n    private int id;\n    private String name;\n    private int money;\n\n    public User(int id, String name, int money) &#123;\n        this.id &#x3D; id;\n        this.name &#x3D; name;\n        this.money &#x3D; money;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;id&#x3D;&quot; + id +\n                &quot;, name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, money&#x3D;&quot; + money +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\n​\t\t\nString sql &#x3D; &quot;select * from table_demo;&quot;;\n&#x2F;&#x2F;注意, DQL语句的方法和其他方法不一样, 会返回一个ResultSet类型的查询结果\nResultSet resultSet &#x3D; statement.executeQuery(sql);\n\n&#x2F;&#x2F;.next()返回下一行是否不为空, 并将指针移动到下一行, 一开始在第一行数据的上一行\nList&lt;User&gt; list &#x3D; new ArrayList&lt;User&gt;();\nwhile (resultSet.next())&#123;\n\n    &#x2F;&#x2F; 用getxxx的方法获取数据, 参数可以填列数, 也可以填列名, 注意! 列数从1开始\n    User user &#x3D; new User(resultSet.getInt(&quot;id&quot;), resultSet.getString(&quot;name&quot;), resultSet.getInt(&quot;money&quot;));\n    list.add(user);\n&#125;\n\nfor (User user : list) &#123;\n    System.out.println(user);\n&#125;\n\nUser&#123;id&#x3D;1, name&#x3D;&#39;张三&#39;, money&#x3D;100&#125;\nUser&#123;id&#x3D;2, name&#x3D;&#39;李四&#39;, money&#x3D;200&#125;\nUser&#123;id&#x3D;3, name&#x3D;&#39;王五&#39;, money&#x3D;300&#125;\nUser&#123;id&#x3D;4, name&#x3D;&#39;赵六&#39;, money&#x3D;400&#125;\nUser&#123;id&#x3D;5, name&#x3D;&#39;刘能&#39;, money&#x3D;500&#125;\n\n\n\n\n\n\n\n\n提示\n一个绝妙的, 字符串合并的方法, 如下\n\n\nString x1 &#x3D; &quot;一段话&quot;;\nString x2 &#x3D; &quot;插入&quot;;\nString x3 &#x3D; &quot;完整&quot;;\n\n&#x2F;&#x2F;这是要达到的结果\nString x &#x3D; &quot;这是一段话, 我要进行一些插入, 让这句话显得完整&quot;;\n\n&#x2F;&#x2F;先这样写,在需要插入的地方写&#39;&#39;\nString m &#x3D; &quot;这是&#39;&#39;, 我要进行一些&#39;&#39;, 让这句话显得&#39;&#39;&quot;;\n\n&#x2F;&#x2F;然后依次添加 &quot;+String+&quot;\n\nm &#x3D; &quot;这是&#39;&quot;+x1+&quot;&#39;, 我要进行一些&#39;&quot;+x2+&quot;&#39;, 让这句话显得&#39;&quot;+x3+&quot;&#39;&quot;;\n\n\n\n\n\n\n\n\n\n\n特别注意\n要小心sql注入, 就是输入的数据经过处理之后影响到查询语句, 我们必须要用\n我们就放弃Statement了, 以后都用PreoaredStatment\n\n\n&#x2F;&#x2F;sql命令变量用 ? 代替\nString sql &#x3D; &quot;select name from table_demo where id &#x3D; ?;&quot;;\nint id &#x3D; 1;\n\n&#x2F;&#x2F;传入sql语句\nPreparedStatement preparedStatement &#x3D; connection.prepareStatement(sql);\n&#x2F;&#x2F;设置变量值, 排序还是从1开始\npreparedStatement.setInt(1, id);\n\n&#x2F;&#x2F;注意不需要再传多余的sql语句了\nResultSet resultSet &#x3D; preparedStatement.executeQuery();\n\n预编译性能更高, 所以用就完事了. 注意后面添加的参数, 添加参数要用?分割, 每个参数之间用&amp;连接\nString url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jdbc_demo?useServerPrepStmts&#x3D;true&quot;;\n\n数据库连接池这个就不做过多展开, 留一个学习传送门吧\n\n\n\n\n\n\n提示\nalt + 鼠标左键 可以实现列编辑\nctrl + alt + l 格式化\n\n\n","slug":"MySql/MySql-Study-day01","date":"2022-11-14T11:33:12.000Z","categories_index":"Study","tags_index":"MySql","author_index":"Someone Serious"},{"id":"a87786c9ccb2deebec2cb0b25e4021c7","title":"Java web Study day01","content":"黑马程序员新版JavaWeb基础教程，Java web从入门到企业实战完整版_哔哩哔哩_bilibili\n喂喂喂听得到吗!\n今天想看电影, 没人陪我看, 真tmd, 我感觉要学的东西快学不完了, G!\n我的mysql的服务器创建了, 账号为root, 密码为S\n不行了, 洗个衣服去看电影了. 估计又要明天再写了,\n\n我的javaWeb主要用来写整体的项目, 而不是单个的测试.\n关于sqlSessionFactory被重复创建的问题我们需要创建一个工具类来获取sqlSessionFactory.\npublic class sqlSessionFactoryUtil &#123;\n\n    private static SqlSessionFactory sqlSessionFactory;\n    \n    \n    &#x2F;&#x2F; 静态代码块只会被执行一次, 就在类被创建时执行, 所以我们就有了唯一的sqlSessionFactory\n    static &#123;\n        String resource &#x3D; &quot;mybatis-config.xml&quot;;\n        InputStream inputStream &#x3D; null;\n        try &#123;\n            inputStream &#x3D; Resources.getResourceAsStream(resource);\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n        sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);\n    &#125;\n\n    public static SqlSessionFactory getSqlSessionFactory()&#123;\n        return sqlSessionFactory;\n    &#125;\n\n&#125;\n\n\nJSPjsp &#x3D; html + java\n简单来说就是在html里面嵌套java代码, 这样导致前后端不能分离, 网页不能单独打开, 需要构建.class文件, jsp现在已经过时了, 但是还是需要了解一下, 因为以前的网页基本都是jsp干的. \n我们需要先导入jsp的包\n\n\n\n\n\n\n\n\n注意\n记得更改jsp的编码方式\n&lt;%@page contentType&#x3D;&quot;text&#x2F;html&quot;%&gt;\n&lt;%@page pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;\n\n\n\n&lt;html&gt;\n&lt;body&gt;\n&lt;h2&gt;Hello World!&lt;&#x2F;h2&gt;\n\n&lt;%-- &lt;%...%&gt;用于编写java代码  --%&gt;\n&lt;%\n    System.out.println(&quot;hello jsp&quot;);\n    int i &#x3D; 0;\n    show();\n%&gt;\n\n&lt;%--下面的用于直接输出java代码中的变量等信息--%&gt;\n\n&lt;%&#x3D; i%&gt;\n\n&lt;%--每一个jsp相当于一个类, 下面的方法是定义这个类中的成员变量或者方法--%&gt;\n&lt;%!\n    private int x &#x3D;0; \n    private void show()&#123;\n        System.out.println(&quot;show&quot;);\n    &#125;\n%&gt;\n\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nEL表达式用来获取数据, 通过$&#123;x&#125;, 这个数据是通过查询匹配得到的, 查询顺序是\n\nJSTL标签要使用JSTL标签需要导入两个包, 然后导入一段代码. \n\n&lt;dependency&gt;\n  &lt;groupId&gt;jstl&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;1.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n  &lt;groupId&gt;taglibs&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;standard&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;1.1.2&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n它是通过标签的方式替代java代码, 让文件可读可扩展性更强一点.\n\n\n\n\n\n\n\n\n注意\n如果它不起作用, 记得补上\n&lt;%@ page isELIgnored&#x3D;&quot;false&quot; %&gt;\n&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;\n\n\n\n","slug":"javaWeb/Java-web-Study-day01","date":"2022-11-13T10:49:34.000Z","categories_index":"Study","tags_index":"javaWeb,jsp","author_index":"Someone Serious"},{"id":"d8446112450bdc11bfa73254c1a2fc8c","title":"Spring Study day02","content":"前言今天是周末, 又是学习的一天, 从早学到晚, 感觉自己的腰椎要顶不住了. (；へ：)\n承接上文的xml配置对数组进行赋值private List&lt;String&gt; list;   &#x2F;&#x2F;注意这里是List 不是ArrayList\n\nprivate other o;\n\npublic User(int x, String str, List&lt;String&gt; list, other o) &#123; &#x2F;&#x2F;注意这里也是List, 不是ArrayList\n    this.x &#x3D; x;\n    this.str &#x3D; str;\n    this.list &#x3D; list;\n    this.o &#x3D; o;\n&#125;\n\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.myCompany.helloWorld.User&quot;&gt;\n    &lt;constructor-arg name&#x3D;&quot;o&quot; ref&#x3D;&quot;s&quot;&#x2F;&gt;\n\n    &lt;constructor-arg name&#x3D;&quot;str&quot; value&#x3D;&quot;&lt;String&quot;&quot;&#x2F;&gt;\n\n    &lt;constructor-arg name&#x3D;&quot;x&quot; value&#x3D;&quot;123&quot;&#x2F;&gt;\n    &lt;constructor-arg name&#x3D;&quot;list&quot;&gt;\n\n        &lt;list&gt;\n            &lt;value&gt;abc&lt;&#x2F;value&gt;\n            &lt;value&gt;def&lt;&#x2F;value&gt;\n            &lt;value&gt;ijn&lt;&#x2F;value&gt;\n            &lt;value&gt;mkl&lt;&#x2F;value&gt;\n        &lt;&#x2F;list&gt;\n\n    &lt;&#x2F;constructor-arg&gt;\n&lt;&#x2F;bean&gt;\n\n\n\n\n\n\n\n提示\nList与ArrayList的区别\nArrayList是List的实现类, List只是一个接口. 所以下面的代码可以实现:\nList list &#x3D; new List();&#x2F;&#x2F;报错\nList list &#x3D; new ArrayList();&#x2F;&#x2F;正确\n\n\n\n集合和字典:private Map&lt;String, String&gt; map;\nprivate Set&lt;String&gt; set;\n\n&lt;constructor-arg name&#x3D;&quot;map&quot;&gt;  &lt;!--换成property都是一样的---&gt;\n\n    &lt;map&gt;\n        &lt;entry key&#x3D;&quot;张三&quot; value&#x3D;&quot;zhangsan&quot;&#x2F;&gt;\n        &lt;entry key&#x3D;&quot;李四&quot; value&#x3D;&quot;lisi&quot;&#x2F;&gt;\n    &lt;&#x2F;map&gt;\n\n&lt;&#x2F;constructor-arg&gt;\n\n&lt;constructor-arg name&#x3D;&quot;set&quot;&gt;\n\n    &lt;set&gt;\n        &lt;value&gt;张三&lt;&#x2F;value&gt;\n        &lt;value&gt;李四&lt;&#x2F;value&gt;\n        &lt;value&gt;王五&lt;&#x2F;value&gt;\n        &lt;value&gt;赵六&lt;&#x2F;value&gt;\n    &lt;&#x2F;set&gt;\n\n&lt;&#x2F;constructor-arg&gt;\n\n\n\n\n\n\n\n提示\nSystem.out.println(Arrays.toString(list)); &#x2F;&#x2F; 注意里面放的是数组, 不是List, 这个方法可以快速格式化输出数组\n\n\n\n注入对象类型值&lt;entry key-ref&#x3D;&quot;test&quot; value&#x3D;&quot;zhangsan&quot;&gt;&lt;&#x2F;entry&gt;\n\n其他同理\n通过util产生公共的对象, 然后引用首先要改变xml\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:util&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&quot; \n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&#x2F;spring-util.xsd&quot;&gt;\n\n注意上面的xmlns:util是新的添加, 还有在xsi上面新加的链接,\n声明公共的对象\n&lt;util:list id&#x3D;&quot;list&quot;&gt;\n    &lt;value&gt;张三&lt;&#x2F;value&gt;\n    &lt;value&gt;李四&lt;&#x2F;value&gt;\n    &lt;value&gt;王五&lt;&#x2F;value&gt;\n    &lt;value&gt;赵六&lt;&#x2F;value&gt;\n&lt;&#x2F;util:list&gt;\n\n然后其他对象可以通过ref引入\n\n\n\n\n\n\n\n注意\n这里的引入引入的都是同一个对象, 地址一致\n\n\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.myCompany.helloWorld.User&quot;&gt;\n    &lt;constructor-arg name&#x3D;&quot;list&quot; ref&#x3D;&quot;list&quot;&#x2F;&gt;\n    &lt;constructor-arg name&#x3D;&quot;list2&quot; ref&#x3D;&quot;list&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n\n\nfactoryBean与普通beanfactoryBean返回类型是可自定义的, 只要引用FactoryBean的接口, 重写getObject()就可以实现, 但是我估计用不到, 所以就不详细展开了. \n单实例与多实例\n\n\n\n\n\n提示\n单实例的意思就是, 只有一个实例, 多个人引用的是同一个对象, 地址是一致的, 多实例就是每次引用创建一个新的对象, 地址之间不一致\n\n\n设置单实例与多实例:\n系统默认是单实例\n@Test\npublic void test()&#123;\n\n    ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);\n\n    User user1 &#x3D; applicationContext.getBean(&quot;user&quot;, User.class);\n    User user2 &#x3D; applicationContext.getBean(&quot;user&quot;, User.class);\n    System.out.println(user1);\n    System.out.println(user2);\n\n\n&#125;\n\n结果:\ncom.myCompany.helloWorld.User@1cab0bfb\ncom.myCompany.helloWorld.User@1cab0bfb\n\n进程已结束,退出代码0\n\n注意上面的结果, 地址值是一样的.\n设置多实例:\n&lt;!--    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.myCompany.helloWorld.User&quot; scope&#x3D;&quot;singleton&quot;&gt;--&gt;\n    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.myCompany.helloWorld.User&quot; scope&#x3D;&quot;prototype&quot;&gt;\n        &lt;constructor-arg name&#x3D;&quot;list&quot; ref&#x3D;&quot;list&quot;&#x2F;&gt;\n        &lt;constructor-arg name&#x3D;&quot;list2&quot; ref&#x3D;&quot;list&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n设置scope, 默认值是singleton,意思是单实例, 设置为prototype,多实例.\nbean的生命周期\n初始化(执行构造方法)\n\n调用set方法\n\n调用初始化方法(如下面代码的init-method)\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.myCompany.helloWorld.User&quot; scope&#x3D;&quot;prototype&quot; init-method&#x3D;&quot;helloWorld&quot;&gt;\n    &lt;constructor-arg name&#x3D;&quot;list&quot; ref&#x3D;&quot;list&quot;&#x2F;&gt;\n    &lt;constructor-arg name&#x3D;&quot;list2&quot; ref&#x3D;&quot;list&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\nbean实例获取, 就是:\nUser user1 &#x3D; applicationContext.getBean(&quot;user&quot;, User.class);\n\n销毁, 销毁的不是某一个bean, 而是整个xml配置实例,销毁代码:\nApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);\n((ClassPathXmlApplicationContext)applicationContext).close();\n\n&lt;bean id&#x3D;&quot;user2&quot; class&#x3D;&quot;com.myCompany.helloWorld.User2&quot; scope&#x3D;&quot;singleton&quot; destroy-method&#x3D;&quot;destroy&quot;&#x2F;&gt;\n\n注意上面代码的destroy-method, 就是销毁会调用的方法\n\n\n\n\n\n\n\n\n提示\n然而在多实例的bean中, destroy方法并不会被调用, 将bean销毁之后, 不会影响到它已经产生的类. 单实例的bean是在xml被实例化时候被创建的, 而多实例的bean是在被具体实例化时被创建的, 所以即使没有只创建的关于xml的实例化, 没有创建类的实例化, xml中的单实例类的初始化方法仍然会被调用, 而多实例则不会\n\n\nbean属性自动注入通过autowire的方式, 但是我们用不到. 百度再说\n德鲁伊连接池首先在maven中导入\n&lt;dependency&gt;\n  &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;1.2.4&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n然后在配置文件中更改:\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;\n\n\n    &lt;context:property-placeholder location&#x3D;&quot;jdbc.properties&quot;&#x2F;&gt;\n\n注意前面的xmlns与xsi中的更改, 在location中填写**.properties**文件\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.myCompany.helloWorld.User&quot; scope&#x3D;&quot;prototype&quot;&gt;\n    &lt;property name&#x3D;&quot;x1&quot; value&#x3D;&quot;$&#123;prop.x1&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;x2&quot; value&#x3D;&quot;$&#123;prop.x2&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;x3&quot; value&#x3D;&quot;$&#123;prop.x3&#125;&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n下面是properties文件, 这个文件我放在了和xml文件一样的resouces文件夹下. \n\n\n\n\n\n\n\n注意\n等号后面不要用空格\n\n\nprop.x1&#x3D;123\nprop.x2&#x3D;456\nprop.x3&#x3D;789\n\n\n\n注解方式管理Bean注解需要aop的包, 我们通过maven引入\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-aop&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;5.3.23&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n注解方式开启需要组件扫描, 在xml配置文件中, 我们仍然要引入context. 然后开启组件扫描:\n&lt;context:component-scan base-package&#x3D;&quot;com.myCompany&quot;&#x2F;&gt;\n\n\n\n\n\n\n\n提示\n在包路径里, 只写上层路径的意思是, 下层路径全部扫描, 如果想扫描多个包, 可以后面跟逗号, 注意: 逗号后面的路径也是全路径. \n\n\n&#x2F;&#x2F; 下面是注解的写法, 有四种@, 其实意思都一样, 只不过每一种@用在项目中的不同结构上, \n&#x2F;&#x2F; value就是唯一标识的id, 如果不写, 默认值就是类名, 但是首字母会小写\n\n@Component(value &#x3D; &quot;user&quot;)\n&#x2F;&#x2F;@Service\n&#x2F;&#x2F;@Controller\n&#x2F;&#x2F;@Repository\npublic class User &#123;\n\n    String x1;\n    public void helloWorld() &#123;\n\n        System.out.println(&quot;创建User成功&quot;);\n        System.out.println(x1);\n    &#125;\n\n    public void theEnd()&#123;\n        System.out.println(&quot;销毁User成功&quot;);\n    &#125;\n&#125;\n\n\n\n我觉得我有可能会做一个技术汇总, 就是写完这些混沌的知识之后, 总结出一股子脉络, 进项详细的排序, 但是感觉工作量有点大, 估计得等到我之后已经遗忘掉spring知识的时候我才会做一个基于博客的学习博客吧.标签我已经想好了, 就叫studyAgain\n关于context的扫描细节配置&lt;!--    use-default-filters默认为true, 表示意思是全部自动扫描, 选择false就表示不扫描, --&gt;\n&lt;!--    context:include-filter表示添加扫描文件, 后面的Controller表示只扫描@Controller的类\n        context:exclude-filter 和上面的相反, 表示不扫描什么东西--&gt;\n&lt;!--        这个type&#x3D;&quot;annotation&quot;表示的就是关于注释的处理--&gt;\n    &lt;context:component-scan base-package&#x3D;&quot;com.myCompany&quot; use-default-filters&#x3D;&quot;false&quot;&gt;\n        &lt;context:include-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Component&quot;&#x2F;&gt;\n        &lt;context:exclude-filter type&#x3D;&quot;annotation&quot; expression&#x3D;&quot;org.springframework.stereotype.Service&quot;&#x2F;&gt;\n    &lt;&#x2F;context:component-scan&gt;\n\n\n\n注释的注入@Value(value &#x3D; &quot;String x1&quot;)\nString x1;\n\n@Autowired\t&#x2F;&#x2F;表示通过类型自动注入, 但是如果一个类型接口下有多个类就会报错\n@Qualifier(value &#x3D; &quot;other&quot;)  &#x2F;&#x2F;通过id注入, 注意:在被注入的类前记得加@, 让context扫描到这个类, 这两个@一般连用, 虽然我也不知道为什么不能只用@Qualifier\nOther o;\n\n\n\n\n\n\n\n提示\n@Repository可以通过类型和id进行注入, 但是它是java的扩展包中的内容, 而不是spring中的内容, 所以不推荐使用\n\n\n完全注解开发可以完全使用注解而不使用xml文件进行开发, 到这里我们的Spring的IOC就学完啦\n我试试能不能跳转到SpringBoot学习.\n","slug":"springBoot/Spring-Study-day02","date":"2022-11-13T02:10:54.000Z","categories_index":"Study","tags_index":"Spring","author_index":"Someone Serious"},{"id":"f9ae6417e6d1f674d9c49adb056f5b6c","title":"Spring Study day01","content":"学习传送门\n首先明确: spring是为了使项目更加简便而设计的\n\n\n\n\n\n\n提示\nGA版本是稳定版\nSNAPSHOT是快照版\n\n\nSpring项目的创建使用maven, 先创建一个最基本的spring框架:\n写一个类的方法\npackage com.myCompany.helloWorld;\n\nimport javax.xml.bind.annotation.adapters.XmlJavaTypeAdapters;\nimport java.sql.SQLOutput;\nimport org.junit.Test;\n\npublic class User &#123;\n\n    public void helloWorld()&#123;\n        System.out.println(&quot;helloWorld&quot;);\n    &#125;\n\n&#125;\n\n写一个测试类\npackage com.myCompany.helloWorld;\n\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class TestRun &#123;\n\n    @Test\n    public void test()&#123;\n\n        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);\n\n        User user &#x3D; applicationContext.getBean(&quot;user&quot;, User.class);\n        System.out.println(user);\n        user.helloWorld();\n\n    &#125;\n\n&#125;\n\n\n在main下创建一个resources资源文件夹, 存放xml文件, 在xml文件中创建bean\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\n    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.myCompany.helloWorld.User&quot;&gt;&lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n然后运行测试类就可以了\n洗澡去了, 人要馊掉了\n\nIOC容器降低耦合, 将创建新的实体类的任务交给spring, 就是IOC, 上面的实践就是IOC\n它包括:\n1. xml解析\n1. 工厂模式\n1. 反射\n\n反射内容不一定和反射有关, 毕竟这也不是什么专业报告, 而是我的学习日记\njava关于类的初始化:\n类并不是在java项目启动时就全部初始化的, 而是动态的, 在调用到它时才初始化, 初始化便是将类方法中的所有静态的方法启动(构造方法当然也算静态方法, 即使它没有static关键字)\n看下面的代码:\npublic class Initable &#123;  \n    static final int staticFinal &#x3D; 47;  \n    static final int staticFianl2 &#x3D; ClassInitialization.rand.nextInt(1000); \n    static int notFinal &#x3D; 12;\n    static &#123;  \n        System.out.println(&quot;Initializing Initable&quot;);  \n    &#125;  \n&#125;\n\n像staticFinal属于编译期常量, 调用它不需要将类初始化, 注意, 必须要有final成为常量\n像第二三种就必须要初始化才可以调用了, 一旦初始化, 就会启动最后的打印方法\n而调用class.forName可以主动将类加载到内存中 , 主动初始化. \n\nIOC接口\nBeanFactory: IOC开发人员用的底层的, 功能更少, 咱们最好不要用\nApplicationContext: 给你用的, 用就完事了.\n\n\n\n\n\n\n\n提示\nctrl + h 可以打开类的关系图\n\n\n\n这两个方法都可以得到创建xml对象\nFileSystemXmlApplicationContext输入的是绝对路径\nClassPathXmlApplicationContext输入的是在src下的相对路劲, 但是我这里好像有点问题, 建议是在main下, 建立一个resouces文件夹, 这个方法也可以直接导航到该目录下\n创建对象之后的注入属性xml配置无参构造set的方法:创建一个类:\npublic class User &#123;\n\n    private int x;\n    private String str;\n\n    private other o;\n\n    public void setO(other o) &#123;\n        this.o &#x3D; o;\n    &#125;\n\n    public void setX(int x) &#123;\n        this.x &#x3D; x;\n    &#125;\n\n    public void setStr(String str) &#123;\n        this.str &#x3D; str;\n    &#125;\n\n    public void helloWorld()&#123;\n        System.out.println(&quot;helloWorld int x &#x3D; &quot; + x + &quot;, str &#x3D; &quot; + str);\n        System.out.println(&quot;the other class : &quot; + o);\n        System.out.println(x + 1);\n    &#125;\n\n\n&#125;\n\n他的配置文件 \n    &lt;bean id&#x3D;&quot;s&quot; class&#x3D;&quot;com.myCompany.helloWorld.other&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.myCompany.helloWorld.User&quot;&gt;\n        &lt;property name&#x3D;&quot;x&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;str&quot; value&#x3D;&quot;str&quot;&#x2F;&gt;\n\n\n&lt;!--        这里引用了s类, 用ref的方法.--&gt;\n        &lt;property name&#x3D;&quot;o&quot; ref&#x3D;&quot;s&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\n有参构造的xml方法:类文件:\npublic class User &#123;\n\n    private int x;\n    private String str;\n\n    private other o;\n\n    public User(int x, String str, other o) &#123;\n        this.x &#x3D; x;\n        this.str &#x3D; str;\n        this.o &#x3D; o;\n    &#125;\n\n    public void helloWorld()&#123;\n        System.out.println(&quot;helloWorld int x &#x3D; &quot; + x + &quot;, str &#x3D; &quot; + str);\n        System.out.println(&quot;the other class : &quot; + o);\n        System.out.println(x + 1);\n    &#125;\n\n\n&#125;\n\n配置文件:\n&lt;!--    注意这里创建了一个s类--&gt;\n    &lt;bean id&#x3D;&quot;s&quot; class&#x3D;&quot;com.myCompany.helloWorld.other&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.myCompany.helloWorld.User&quot;&gt;\n        &lt;constructor-arg name&#x3D;&quot;o&quot; ref&#x3D;&quot;s&quot;&#x2F;&gt;\n        &lt;constructor-arg name&#x3D;&quot;str&quot; value&#x3D;&quot;string&quot;&#x2F;&gt;\n        &lt;constructor-arg name&#x3D;&quot;x&quot; value&#x3D;&quot;123&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n\np方式注入我就提个名字, 想用的话百度吧. \n配置文件特殊用法\n设置空值\n&lt;constructor-arg name&#x3D;&quot;str&quot;&gt;\n    &lt;null&#x2F;&gt;\n&lt;&#x2F;constructor-arg&gt;\n\n用property同理\n\n如果遇到xml会解析到的特殊符号怎么办, 比如&lt;&gt;,可以用转义符号&amp;lt, &amp;gt为&lt;&gt;\n&amp;quot为”\n&lt;constructor-arg name&#x3D;&quot;str&quot; &gt;\n    &lt;!--字符串写在&quot;CDATA[&quot;后--&gt;   \n    &lt;value&gt;&lt;![CDATA[&lt;String&gt;]]&gt;&lt;&#x2F;value&gt;\n&lt;&#x2F;constructor-arg&gt;\n\n使用内部bean赋值\n&lt;constructor-arg name&#x3D;&quot;str&quot; &gt;\n    &lt;bean id &#x3D; &quot;&quot; class &#x3D; &quot;&quot;&gt;\n    &lt;!--进行内部bean的赋值, property同理--&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;constructor-arg&gt;\n\n级联赋值\n其实就是通过ref调用外部bean.\n\n\nIOC与DITheEND好啦, 今天的学习时光就到这里了, 下午两点半创建的文档, 现在已经是11点47了, 好啦886.\n","slug":"springBoot/Spring-Study-day01","date":"2022-11-12T06:33:30.000Z","categories_index":"Study","tags_index":"Spring","author_index":"Someone Serious"},{"id":"76ec667c92deac2437fb208989cf59f5","title":"Maven res 01 HelloWorld","content":"学习传送门\n目的描述​\t1. 创建一个Maven项目, 其中包括父类 maven_parent, 以及他的三个子模块maven_dao, maven_service, maven_controller\n​\t2. 三个子模块的用途与依赖关系\n\n\n\n\nmaven_dao\nmaven_service\nmaven_controller\n\n\n\n简述\n数据库访问层\n项目业务逻辑层\n接受请求,相应数据\n\n\n模板\nquickstart\nquickstart\nwebapp\n\n\n依赖\n\nmaven_dao\nmaven_serviceservlet\n\n\n插件\n\n\ntomcat\n\n\n\n实现过程创建项目\n选择模板项目, 更改项目名称\n\n更改项目ID, 然后刷新Maven\n\n新建模块时注意填写Maven模板\n\n添加依赖\nmaven_dao中的方法\n\n向service中添加dao的依赖, 注意图中的写法\n\n编写service方法, 并引用maven_dao中的方法\n\nmaven_controller方法需要载入插件servlet, 然后实现其中的方法, 超入插件的方法如下:\n\n搜索mvn, 进入Maven库官网, 然后搜索对应的插件, 以及版本, 如果不知道用什么版本, 看人数最多的就可以了.\n\n\n复制代码到pom.xml下\n\n创建servlet类, 重写它的方法, servlet我还没有学, 之后可能会写详细说明\n\n\n然后还要依赖maven_service, pom.xml如下:\n&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;javax.servlet&#x2F;javax.servlet-api --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.1.0&lt;&#x2F;version&gt;\n    &lt;scope&gt;provided&lt;&#x2F;scope&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;dependency&gt;\n    &lt;artifactId&gt;maven_service&lt;&#x2F;artifactId&gt;\n    &lt;groupId&gt;com.myCompany&lt;&#x2F;groupId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n代码重写servlet方法:\n首先发现在controller下没有java这个包, 所以我们要手动创建:\n\n重写方法:\n@WebServlet(&quot;&#x2F;user&quot;)\npublic class UserServlet extends HttpServlet &#123;\n\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        System.out.println(&quot;myServlet complete...&quot;);\n        \n        &#x2F;&#x2F;调用service中的方法:\n        useDao.use_dao();\n    &#125;\n&#125;\n\n\n想要运行的话还是要添加jetty或者tomcat的插件打开服务器, 插件添加在&lt;plugins&gt;下方, 而它又放在&lt;bulid&gt;的下方\ntomcat的插件去tomcat的官网下载:插件官网\n&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.tomcat.maven&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;tomcat6-maven-plugin&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.2&lt;&#x2F;version&gt;\n    &lt;configuration&gt;\n        &lt;hostName&gt;localhost&lt;&#x2F;hostName&gt;        &lt;!--   Default: localhost --&gt;\n        &lt;port&gt;8080&lt;&#x2F;port&gt;                     &lt;!-- 启动端口 Default:8080 --&gt;\n        &lt;path&gt;&#x2F;tomcat&lt;&#x2F;path&gt;   &lt;!-- 访问应用路径  Default: &#x2F;$&#123;project.artifactId&#125;--&gt;\n        &lt;uriEncoding&gt;UTF-8&lt;&#x2F;uriEncoding&gt;      &lt;!-- uri编码 Default: ISO-8859-1 --&gt;\n    &lt;&#x2F;configuration&gt;\n&lt;&#x2F;plugin&gt;\n\n如何使用tomcat启动服务器:\n\n\n注意添加命令, 然后更改下列属性\n\n在启动之前需要将项目打包, 生成target文件\n\n\n\n\n\n\n\n\n注意\n第一次构建项目的时候, 一定要先构建父类, 然后再点击按钮构建项目\n\n\n\n然后我们就运行成功了!\n\n\n\nTheEND","slug":"Maven/Maven-res-01","date":"2022-11-12T03:14:14.000Z","categories_index":"Result","tags_index":"Maven","author_index":"Someone Serious"},{"id":"c2a9e80eefc355aef707e141e0e47a0d","title":"Maven-Study-day01","content":"学习传送门\nMaven帮助我们下载管理依赖的包&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;druid.version&#125;&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\ngroupId: 实际的包的仓库路径, 也就是实际项目公司名称\nartifaceId: 实际项目中的一个Maven模块(项目名), \nversion: 版本\n\n统一jar包依赖\n统一项目目录结构\n一致构建模型插件机制\n\nMaven的统一项目结构\n在若依项目中的体现:\n\npom.xml是用来存放所有的依赖jar包和插件的\n至于pom.xml中的标签含义, 有一个超级pom中包含所有标签, 就在 传送门下面的POM标签大全详解里. \nMaven设置的xml与包路径设置\n在xml中设置包路径如下图, 其中注意是用 /而不是\\\n&lt;!-- 下载包的地址 --&gt;\n&lt;localRepository&gt;D:&#x2F;repository&lt;&#x2F;localRepository&gt;\n\n还可以设置阿里云的镜像, 因为maven的服务器在国外, 下载很慢, 所以设置阿里的镜像会快一点\n&lt;mirrors&gt;\n    &lt;mirror&gt;\n        &lt;id&gt;alimaven&lt;&#x2F;id&gt;\n        &lt;name&gt;aliyun maven&lt;&#x2F;name&gt;\n        &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;\n        &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;\n    &lt;&#x2F;mirror&gt;\n&lt;&#x2F;mirrors&gt;\n\n\n\n下面是创建Maven的过程\n其中archetype是指Maven的模板, 一般选择quickstart就行了, 有特殊需要再更换, 选错了不影响.\n\n更改图中的设置\n\n从图中的按钮处可以进入如图的页面, 进入该页面后可以输入相关命令, 方便执行. 执行的话就点击执行就可以了. \n插件放在:\n&lt;bulid&gt;\n\t&lt;plugins&gt;\n\t\t&lt;plugin&gt;\n            &lt;!--插件放在这里--&gt;\n        &lt;&#x2F;plugin&gt;\n    &lt;&#x2F;plugins&gt;\n&lt;&#x2F;bulid&gt;\n\nweb项目的话, 用jetty(轻量级快速)或者tomcat插件\n在Maven中插件导入\n更改一下Maven中的配置\n在启动项选择中加入启动命令\n启动\n\n\n\n\n\n\n\n\n\n注意\n不行了, 跑步去了, 感觉要烂在椅子上了, 学习使我充实, 也使我疲倦. \n\n\n\n虽然已经是第二天了, 但是这是我既定的一天的学习内容, 所以仍然放在这篇博客. \nMaven仓库类型1. 中央仓库服务器在国外, 是Maven的主要仓库, 默认下载仓库\n2. 本地仓库下载完成之后就存放在本地仓库, 每一个本地项目都从本地仓库中找, 找不到就去中央仓库中下载\n3. 私服局域网中的仓库, 一般在公司中使用, 更快的下载Maven插件\n4. 其他仓库比如国内的阿里云镜像, 是中央仓库与私服的折中选择. \nMaven中创建子模块在父模块的目录上, 右键点击新模块. 而父模块的创建不需要选择Maven模板. \n\n实战实战传送门","slug":"Maven/Maven-Study-day01","date":"2022-11-11T08:41:35.000Z","categories_index":"Study","tags_index":"Maven","author_index":"Someone Serious"},{"id":"48f7fbdaf0e0dd4f6b63c39c2a27cf68","title":"springBoot-Study-day01","content":"先去学习Maven了, 真的和多米诺骨牌一样, 发现自己球也不懂.\n\n学完Maven和Spring的IOC了, 今天开始学习springBoot\nspringBoot是用来快速启动spring了, 解决了spring xml配置的繁琐和包文件的导入麻烦问题. \n\n\n\n\n\n\n提示\nSpringBoot不是对Spring的进一步强化, 而是对Spring的优化, 功能上没有多什么\n\n\n好了, G了, 还是要学Spring\nSSM框架-导学内容_哔哩哔哩_bilibili\n我心态崩了, 还要学tmd javaweb, javaweb又有三十四小时的课! 草了\n","slug":"springBoot/springBoot-Study-day01","date":"2022-11-11T08:23:35.000Z","categories_index":"Study","tags_index":"springBoot","author_index":"Someone Serious"},{"id":"307d6666c3d0b32790212432c57158e1","title":"RuoYi-frame-学习-day03","content":"\n\n\n\n\n\n\n特别注意\n今天不想学习, 只想摆烂, 接下来我要记录一下我打的几把联盟的战绩, 计算了一下, 从我第一天搭建博客, 到现在, 从上周五(4号)到今天, 已经猛干了五天了, 顶不住了. 我们要休息! 我们要争取八小时工作制!\n\n\n我莫甘娜追着豹女跑, 豹女硬顶着我的伤害把基地干爆了, TMD\n我已经放弃学习若依了, 选去搞springBoot","slug":"Ruoyi/RuoYi-frame-学习-day03","date":"2022-11-09T05:12:35.000Z","categories_index":"Study","tags_index":"RuoYi","author_index":"Someone Serious"},{"id":"95d3c68757bee3f9c7ba7e266dc65367","title":"RuoYi frame 学习 day01","content":"\n\n\n\n\n\n\n注意\n今天进入若依框架的学习, 为了天杀的实践课, 这个Guns是真该死啊\n\n首先我们需要一个传送门\n若依前后端分离版主要业务是权限管理系统, 简单易上手, 新手专用开源项目, 练手完美, 还有网课, 真是nice的不要不要的.\n首先就需要框架搭建若依传送门\n\n\n\n\n\n\n\n注意\n基础: SpringBoot + Vue\n\n真是草了, 算了springBoot之后再学, 先搞这个.\n所谓前后端分离, 当然要前端和后端分别打开\n要学的东西是真tmd多啊, 我还要搞\n\nmysql配置\nnavicat使用\nspringboot\nvue\n方便的插入图片\n\n至少第五点已经有解决方案了\n图片解决方案 -&gt; 传送门我感觉一切尽在掌握, 可是我该去吃饭了\n图片的问题已经解决了一半了通过导入插件的办法, 已经可以用如下的代码来解决图片插入的问题, 但是我们还要更换软件, 让插入图片更加舒畅.\n![](img1.png)\n\n我们就要用到 Typora 应用了, vscode 886.\n图片的问题解决了, 只不过最后要通过ctrl + f替换掉所有的题目&#x2F;\n\nmysql配置\n若依数据库配置\n设置url, 用户名,和密码, 说实话, 我这个数据库属实不太会用.\n除了需要配置mysql, 还需要配置Redis 它是另外一款数据库, 现在的我还不明白为什么需要两个数据库, 我现在博客写的这么意识流到底好不好啊?\n安装Redis还要用到虚拟机和Linux, 我的心态要崩了, 东西越学越多, 我真是操了.\nRedis Windows系统的管理器传送门\n还是得要在Linux上使用Redis真是草了, 但是今天的学习也就到这里了. 碎觉去了.\n\n现在已经第二天了, 但是鉴于昨天学的东西并不是很多, 所以我还是在这个post里继续写下去, 我在想是不是要另外开一个档用来存放干活而不是废话. 把这个当成学习日记算了, 这个Study分类就用来一边学习一边摸鱼吧. \n若依启动方式首先前后端都要打开前端就是ruoyi-ui 后端就是总项目里面的ruoyi-admin下面的RuoYiApplication\n启动后端前, 要先注意把数据库和redis都打开, redis启动就直接在resp中运行就可以了, 数据库在idea里面也可以启动. \n\nruoyi-ui下的src下的views下的index.vue是首页的内容. \n\n\n\n\n\n\n提示\n目录页面查找是通过数据库sys_menu来查找的, 里面有它的根目录\n\n\n\nEND今天只能学到这里了, 虽然说是一天, 但实际上是两天, 好啦 886\n","slug":"Ruoyi/RuoYi-frame-学习-day01","date":"2022-11-07T08:03:31.000Z","categories_index":"Study","tags_index":"RuoYi","author_index":"Someone Serious"},{"id":"a9e4774d724b74fc9dfb730280d107de","title":"Markdown Study day 02","content":"第二天起床再写今天晚上先把上传搞好\ntips: 明天改这个图像的BUG修改BUG日志: 好像好了, 又好像没好.\n起床啦建立表格我们需要用---来分割每列的标题, 然后用|来分割每列, 让我来试一下.\n\n\n\n正数\n负数\n0\n\n\n\n大于0的数\n小于0的数\n0\n\n\n|正数 | 负数 | 0 |\n|-----|------|--|\n|大于0的数|小于0的数|0|\n\n但是这样的代码又麻烦又丑, 于是我们必须要一个传送门  \n\n\n\n哺乳动物\n两栖动物\n爬行动物\n\n\n\n人类\n青蛙\n蜥蜴\n\n\n我的评价是, 还可以, 但不是太可以\n脚注不想学, 不好用\n标题编号tip: 我刚刚换了一个md的查看模组, 这个默认的模组很多语法都不识别.\n那么我这个标题编号的标题已经添加了标题编号方法如下\n## 标题编号\n\n    [Heading IDs](#heading-ids)\n\n然后就可以超链接过去了我把标题编号删了, 因为我发现系统会自动添加标题编号, 编号就是标题名称.链接到起床了感觉用起来还不错\n定义列表效果展示:  \n这是一个列表头: stuff1: stuff2stuff3这是下一个列表头: stuff1: stuff2stuff3这是一个列表头\n: stuff1\n: stuff2\n: stuff3\n\n这是下一个列表头\n: stuff1\n: stuff2\n: stuff3\n\n我的评价是: 捞的么淌口水\n删除线这个功能已经不被需要了, kill!\n~~这个功能已经不被需要了~~\n\n我很想知道快速创建代码块围栏的快捷键, 一个一个敲太麻烦了.装载了一个markdown shortcut 又有一堆指令要学习, 怎么感觉又麻烦了起来  !!!∑(ﾟДﾟノ)ノ\n任务列表语法- [x] Write the press release\n- [ ] Update the website\n- [ ] Contact the media\n\n\n Write the press release\n Update the website\n Contact the media\n\nmarkdown快捷键这里我想粘贴一张图片\n\n\n注意这里我没有使用markdown的语法, 我使用了hexo的语法\nhexo粘贴图片首先配置文件要先打开图片  \n_config.yml\npost_asset_folder: true\n\n然后把图片放在和post同名的文件夹下, 然后使用以下的命令\n&#123;% asset_img slug page1.png %&#125;\n&#x2F;&#x2F;注意, 这里的图片名字为 page1.png\n\n然后其他需要被引用到的元素都可以用hexo来解决解决的方法是通过传送门\n现在已经九点半了, 一会去上课, 晚上接着写这个GitHub的网络真的很不稳定\n上完课了, 晚上还要上选修课, 真tmd\n表情我觉得使用基本颜文字就可以了, 这个markdown表情感觉有点捞的不谈:imp::imp::imp:\n这里我们需要一张图片和一个传送门\n\n\n好啦! 这个markdown学完啦我们还可以继续学习这个模板的特殊语法语法很简单\n\n\n\n\n\n\n提示\n这是一个tip\n\n:::tip\n这是一个tip\n:::\n\n\n\n\n\n\n\n\n注意\n这是一个warning!!!\n\n:::warning\n这是一个warning!!!\n:::\n\n\n\n\n\n\n\n\n特别注意\n这是一个Danger!!!\n\n:::danger\n这是一个Danger!!!\n:::\n\n\nClick to see more\n点一个按钮可以看更多, 真是有够骚  \n\ndetails content\ndetails new line\n\nconsole.log(&#39;hello world&#39;)\n\n\n\n\n:::details Click to see more\n\ndetails\n\n- details content\n- details new line\n\n~~~javascript\nconsole.log(&#39;hello world&#39;)\n~~~\n\n:::\n\n\nEND结束了\nmarkdown就算彻底学完啦\n","slug":"mark/Markdown-Study-day-02","date":"2022-11-07T00:36:21.000Z","categories_index":"Study","tags_index":"Markdown","author_index":"Someone Serious"},{"id":"e9beb6261539d5bfbef19aa72e68381a","title":"Markdown Study day 01","content":"这是我的第一篇博客 (^▽^)进入Markdown学习众所周知Markdown是一款轻量级的语言，用于…后面的废话就不用说了，搞得跟真的一样。据说能在半个小时内掌握,我信他个鬼.(ｰ̀дｰ́)\n粘贴一个学习网址 https://markdown.com.cn/basic-syntax/\n\n使用标题就是通过前方加#的方式  \n # 一级标题\n## 二级标题\n### 三级标题\n\n段落前不要加双空格,没有用的,而且也没有必要(当然,我写这些有的没的tips其实还是在间接锻炼我的打字速度和使用Markdown的能力)\n\n换行可以加一个&lt;br&gt;或者加两个空格然后回车(注意区别换行和更换段落的区别)\n\n接下来是 粗体 与 斜体,至于又是粗体又是斜体,聪明的你应该已经猜到相应的语法了吧\n **粗体**\n*斜体*\n\n tips： 我现在的Markdown写的看起来非常的丑，但是估计之后会越写越好看，毕竟这是一个学习的过程。\n\n引用：\n\n\n\n\n\n\n\n\n\n今天真是他妈的学习的好日子，我终于可以狗娘养的学一天了 ————SomeoneSerious 2022.11.6\n &gt;引用，就这样写就可以了\n\n 注意我现在还不会引用缩进以及其他格式\n\n引用嵌套：\n\n\n\n\n\n\n\n\n\n这是一个父级引用\n\n这是一个子集引用\n\n &gt;这是一个父级引用\n&gt;&gt;这是一个子集引用\n\n 至于怎么让子级引用退回父级引用，我还不会。真tmd\n\n无序列表：\n 写到这里了，突然想放歌，至于我的博客为什么写的这么意识流，大概是因为没人看所以可以随心所欲吧。\n 大概效果是这样的\n\n我不知道该写点啥\n我还是不知道\n无所谓了\n换行\n牛不牛\n还能继续\n\n\n\n\n\n 这个地方的代码展示还有点困难。但是我会了(两个小时之后的我).\n * 我不知道该写点啥\n* 我还是不知道\n* 无所谓了\n    * 换行\n    * 牛不牛\n        * 还能继续\n\n代码块\n\n创建代码块就是通过搞四个空格就可以了（用软件的话一个tab &#x3D; 四个空格)  \n还可以使用围栏式的方法：\n\n 这是效果\n\n &#96;&#96;&#96;\n    这是代码\n    \\&#96;&#96;&#96;  没有前面的&quot;\\&quot;\n\n\n用 **`** 包围起来变量名或者其他代码名字，可以更加凸显，效果: createIdot()\n如果想用语法高亮的话，要再```后面加上这段语言的名字，试一下效果\n\n &#123;\n&#x2F;&#x2F; &#96;&#96;&#96;json\n&#x2F;&#x2F; code\n&#x2F;&#x2F; &#96;&#96;&#96;\n\n&#x2F;&#x2F; 这是我随便抄来的一段没有什么意义的代码，就是为了看看高亮。（被窝里看夜光手表）\n&quot;name&quot;: &quot;hexo-site&quot;,\n&quot;version&quot;: &quot;0.0.0&quot;,\n&quot;lockfileVersion&quot;: 2,\n&quot;requires&quot;: true,\n&#125;\n\n分割线\n\n就是通过使用***，就可以了\n\n\n\n上面就是一条分割线   \n\n 刚才改了一下中文输入时仍然用英文标点,不然实在是切换来切换去太麻烦了,\n\n超链接语法\n\n我觉得发明这种语言的人是一个天才, 在大家都追求个性的时候,通过这种单调的语言和单调的格式, 强行大大化减了办公难度, 我觉得这会成为一种趋势, (逗号后面得跟一个空格了, 因为现在在使用英文标点, tmd).就是现在一切都变得非常复杂, 就是为了应对人们刁钻的需求, 可是那些按钮大部分人一辈子也不会点一次, 但是缺经常能看到, 这是一件非常折磨的事情, 所以应该做一种应用定制, 而不是吃需求的大锅饭. 开发一款平台, 招募一大堆写脚本的程序员, 提出需求, 私人订制应用, 和跳蚤市场一样, 当人们有钱的时候, 这应该会是一个大市场.\n\n[超链接语法](https:&#x2F;&#x2F;markdown.com.cn)\n[Markdown语法](https:&#x2F;&#x2F;markdown.com.cn &quot;最好的markdown教程&quot;)。&#x2F;&#x2F;说实话, 这个 最好的教程 说的多少有点不要face.   \n\n\n效果Markdown语法感觉没p用\n其他\n\n&lt;尖括号里面写地址就是可以点的链接, 但是得写全&gt;\n\nhttps://www.baidu.com\n链接加粗加斜都是可以的, 还可以用 ` 加成标记code\n[&#96;code&#96;](&quot;https:&#x2F;&#x2F;www.baidu.com&quot;)\n[&#96;code&#96;](#code)\n\n睡觉去了, 睡半个小时起来再写.\n\n\n","slug":"mark/Markdown-Study-day-01","date":"2022-11-06T13:23:19.000Z","categories_index":"Study","tags_index":"Markdown","author_index":"Someone Serious"},{"id":"39367ba552a6a0ef310b797e6ac7a1d6","title":"inspiration","content":"像音乐一样的哲学\n\n\n\n\n\n提示\n于2022.11.7 夜 上选修课有感\n\n\n哲学应该像黑格尔的比喻一样, 重点不在于每一个音符, 而是每一个音符谱成的乐章, 这个乐章中的每个音符都参与到这个乐章中, 成为乐章中的一部分而不是杂音. 每一句都有道理的人不一定哲学素养高深, 他们的道理常常自相矛盾, 拾人牙慧, 哲学的重点在于体系, 成体系的, 流畅的, 自洽的, 完整的哲学体系, 就像一谱乐章一样. \n\n手套鼠标\n\n\n\n\n\n提示\n于2022.11.11午 看小视频有感\n\n\n你说, 把鼠标设计成手套的样子会不会很酷, 手套部分地方是固定的, 部分地方是活动的, 保持一个弓形, \n\n倒着走的时间\n\n\n\n\n\n提示\n于博客纪元之前玩 游戏新手指南时有感\n\n\n我们在时间的长河中不是面朝前注视着前方正向走的, 而是面朝后方倒退着走的, 我们只能看到过去, 每每回头展望未来时, 看到的都是虚影. 倒着走有一股强烈的不安感, 所以人们才会焦虑吧. \n\n焦虑与奋斗与躺平\n\n\n\n\n\n提示\n于2022.11.11 夜 在食堂回宿舍路上有感\n\n\n我到底是因为焦虑而躺平还是因为躺平而焦虑, 或者说躺平与奋斗谁能否医治我的焦虑, 奋斗到了瓶颈又怎么办, 在不断地运动中人才能得以慰藉吗, 一潭死水为什么会焦虑呢? 到底是我特殊还是世人大抵如此. \n\n暴力革命\n\n\n\n\n\n提示\n于博客纪元之前 知乎有感\n\n\n为什么历史上鲜有和平革命, 大部分都是流血暴动, 因为断人财路好似杀人父母, 杀父之仇不共戴天, 不流血干不成, 世界是分割的, 人不是理性的, 讲道理是讲不通的. \n\n当代互联网奇观\n\n\n\n\n\n提示\n于2022.11.15 中午与猪出去吃饭有感\n\n\n典急孝乐蚌赢麻寄\n\n\n微信托管\n\n\n\n\n\n提示\n于2022.11.16 夜上实践课老师的想法\n\n\n设计一款微信托管应用, 等我死了以后依然可以发微信, 发朋友圈. \n\n情绪与伤口\n\n\n\n\n\n提示\n于2022.11.23 午, 被崔气了之后的想法\n\n\n我觉得负面的情绪就像是伤口, 我们的愤怒, 悲伤, 嫉妒等等负面情绪就像是各种各样的疾病或者伤口, 我们在碰到恶劣的环境或者危险的处境时, 我们会受伤, 会得病, 同样的, 我们在逆境中情绪也会”得病”, 它是我们生存环境的真实反馈. \n处理这种伤口的方法有两种, 一种是不加以干预让其自愈, 对于情绪我们也可以这样做, 这样会让心智更加成熟, 另一种方法就是人工干预, 加以医疗手段, 比如骨折我们当然不能自愈, 对于负面情绪, 当其强烈到一定程度之后我们也不能全指望自愈了, 一定需要给他安排发泄的手段, 不然人会憋坏, 这就是为什么人要喝酒抽烟, 骂脏话. \n但是实际上我们对于情绪还有第三种处理方法, 叫否定. 这种处理方法非常常见, 非常病态. 一个人受伤得病, 对别人说我很难受, 我们不会说:”不, 你不难受”, 但是当一个人心情十分低落, 对我们发出求助时, 我们却会说:”不, 你不难过”, 甚至会加以佐证, “你看过去人生活条件多么艰苦, 你生活条件这么好, 你怎么会难过呢?你应该感到开心才对, 所以得证, 你不难过.”对于情绪的否定是一件常见的事情, 这样做的坏处有很多, 首先它并不能真正解决问题, 甚至比放任不管让其自愈的效果还要差, 其次, 假如有人在长期被这样说教的情况下真的相信了这样的论证, 那才是真正的大难临头, 他会相信这样的情绪是”正面的”, 他会在价值观上赞美这种情绪, 他会鄙夷那些每天活在快乐中的人, 认为他们活在”痛苦之中”, 更进一步的话, 他们就变成了苦行僧. \n战场上的士兵会把伤疤当做自己的勋章, 因为这些伤疤证明了他们在战场上的英勇无畏. 那些苦行僧, 把痛苦的情绪当做了自己的勋章, 试图证明自己心灵的强大, 我是这样认为的, 士兵受伤是因为没有办法, 战场上他们英勇陷阵, 他们并不索求伤痕, 他们为了快乐而战, 但是苦行僧不同, 他们追求痛苦, 以达到没有痛苦可以伤及他们的程度, 但他们依然会有快乐, 他们快乐的来源是用他们充满伤痛的人生来鄙视那些天真快乐的孩子们, 以获得一些浅薄的优越感, 这种优越感的来源并不是他们自身, 而是这个社会的价值评判体系的倾向.\n\n聊天室与敲钟牛:::\n于2022.12.1，与米河探讨物联网有感\n:::\n米河的开化程度那是相当的高，虽然说这话可能会显得我很高高在上，但其实老子就是牛逼. \n聊天室可以通过发送特定的指令, 来让接收端有一个绑定的小玩具运作, 来达到传递消息的作用,  这样会非常有仪式感. \n\n富贵不能淫:::\n于2022.12.28, 刷知乎时有感\n:::\n富贵不能淫, 那我还要富贵有何用. 传统的道德观把人的物质生活大概划分为三个阶段, 生存, 生活, 淫. 富贵不能淫的意思大概是, 即使有钱了也不能淫, 而是要生活, 并帮助只能生存的人也生活, 颇有先富带后富的思想. \n但是这种简单的观点是形而上的, 是颇具浪漫主义气息的. 因为人们对生活的评价不是静态的, 是动态的, 富贵的人不认为他们在淫, 而是在生活, 而生存的人也未必觉得自己在生存, 也可能真的知足常乐, 追求共同富裕是否是像民主一样只是虚假的政治广告呢, 我对富贵是有追求的, 可是我身边很多比我贫贱的人却没有追求, 我到底特殊在哪呢? 还是因为我吃了苦, 所以就想要阶级攀升, 不然就心不平. 如果这样说, 富贵只不过是我心不平的出火口. \n我过去认为人是最有意思的, 但是这种想法其实本身就很变态, 因为人与人之间的感情传递可以很极端, 人们在某种事件上专注到一定程度就会走极端, 比如游戏的成就党, 各种收藏爱好家等, 要是追求人与人之间感情的极端, 这是一种很病态的状态, 但是, 这种事情总是说不清, 说不定我该看看书补充一下我自己了, 但是最近又想玩艾尔登法环. \n\n仪式感:::\n于2023.1.1午夜, 跨年夜有感\n:::\n仪式感就是装逼, 装逼是刚需, 仪式感是装逼的一种, 有钱人的仪式感特别重, 因为有大量装逼的需求, 就是作为精神需求. \n\n","slug":"inspiration/inspiration","date":"2022-11-06T12:46:46.000Z","categories_index":"Other","tags_index":"","author_index":"Someone Serious"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo!\n\nclick there to know more\n this is my First blog, if you are here, it’s a pretty weired thing, because I never introduce people to this article, But if you find this, I will give you a gift. How to get it?\nCall me 叶良辰, you will get it.\n\n\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-11-06T12:27:47.711Z","categories_index":"","tags_index":"","author_index":"Someone Serious"}]